\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{url}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%

\definecolor{lightyellow}{rgb}{1,0.98,0.9}
\definecolor{lightpink}{rgb}{1,0.94,0.95}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title{Ethereum: Un Registro Generico delle Transazioni Sicuro e Decentralizzato \\ {\smaller \textbf{Final Draft - UNDER REVIEW}}}
\author{
    Dr. Gavin Wood\\
    Co-Founder \& Lead, Ethereum Project\\
    gavin@ethereum.org\\
    Tradotto dal Dr. Leonardo Maria Pedretti\\
    Founder \& Lead, Ethereum Project Italia\\
}
\begin{document}

\pagecolor{lightyellow}
%\pagecolor{lightpink}

\begin{abstract}
Il paradigma blockchain, quando associato alle transazioni rese sicure dalla crittografia, ha dimostrato la propria utilità attraverso diversi progetti, non da ultimo il Bitcoin. Ognuno di questi può essere visto come una semplice applicazione su una decentralizzata, ma con un solo fine, risorsa di calcolo. Possiamo definire questo paradigma come una macchina con un unico scopo ma con uno stato condiviso.

Ethereum implementa questo paradigma con un un ecosistema generico. Inoltre fornisce una plurità di dette risorse, ognuna con uno stato e con un codice operativo distinto, ma capace di interagire con gli altri attraverso un framework che consente la comunicazione per mezzo di messaggi fra questi. Abbiamo discusso sul proprio design, le problematiche dell'implementazione, le opportunità che fornisce e gli ostacoli futuri che prevediamo.
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}

\section{Introduction}\label{sec:introduction}

Con la diffusione capillare di internet in molti posti del mondo, la trasmissione di informazioni è divenuta incredibilmente economica. I movimenti fondati sulla tecnologia come il Bitcoin hanno dimostrato, attraverso la forza del predefinito meccanismo di consenso e del rispetto volontario del contratto sociale, come sia possibile utilizzare internet per creare uno sistema decentralizzato di scambio di valore, condiviso attraverso il mondo e virtualmente libero da utilizzare. Questo sistema può essere definito come una versione molto specializzata di una, crittograficamente sicura, macchina di stato basata sulla transazione. I successivi sistemi come il Namecoin hanno adattato questa originale ``applicazione monetica'' della tecnologia in altre in maniera piuttosto semplicistica.

Ethereum è un progetto che tenta di costuire una tecnologia generalizzata; dove tutte le idee basate sulla macchina di transizione di stato possono essere implementate. Inoltre esso mira a fornire allo svilupattore finale un sistema end-to-end molto integrato per la costruzione di software su un paridgma di calcolo nel finora inesplorato nel mainstream: un framework computazionario di fiducia che scambia messaggi.

\subsection{Driving Factors} \label{ch:driving}

Molti sono gli obiettivi di questo progetto; il principale è quello di facilitare le transazioni consentendo agli individui, che altrimenti non avrebbero mezzi, di fidarsi tra di loro. Ciò potrebbe derivare dalla distanza geografica, la difficoltà ad incontrarsi, o probabilmente all'incompatibilità, incapacità, riluttanza, costi, incertezza, non convenienza o la corruzione dei sistemi legali esistenti. Fornendo le specifiche per lo sviluppo di un sistema di cambio di stato attraverso un linguaggio ricco e chiaro ed architettando un sistema come questo, possiamo ragionevolmente aspettarci che un accordo sarà ottemperato automaticamente, procurando un mezzo per tale fine.

Conseguentemente il suddetto sistema avrebbe diversi attributi non spesso rinvenibili nel mondo reale. L'incorrutibilità di un giudizio, spesso difficile da trovare, perviene naturalmente da un interprete algoritmico disinteressato. La trasparenza, o l' essere in grado di osservare con esattezza come uno stato o un giudizio giunto attraverso il log della transazione e le regole o i codici di istruzione, non avviene mai in modo perfetto nei sistemi incentrati sull'uomo, perchè il linguaggio naturale è per necessità vago, spesso le informazioni sono carenti, e i vecchi e diffusi pregiudizi sono difficili da scrollari di dosso.

Complessivamente, mi auguro di fornire un sistema nel quale gli utenti possano essere garantiti del fatto che non importa con quali altri individui, sistemi od organizzazioni possano interagire, potendo confidare del tutto sui possibili risultati e il modo in cui questi siano pervenuti.

\subsection{Previous Work} \label{ch:previous}

\cite{buterin2013ethereum} il primo "cuore" di questo lavoro è stato proposto a fine novembre 2013. Sebbene ora si sia evoluto in molti modi, la funzionalità chiave della blockchain con un linguaggio Turing-complete ed una capienza di storage concretamente illimitata rimane inalterata.

Hashcash, introdotto da \cite{back2002hashcash} (in a five-year retrospective), fornì il primo prototipo che faceva uso di una prova crittografica del consumo computazionale come mezzo per  trasmettere un segnale che veicolasse un valore per mezzo di Internet. Anche se non adottato ampiamente, il lavoro fu più tardi utilizzato ed esteso da \cite{nakamoto2008bitcoin} al fine di elaborare un meccanismo crittograficamente sicuro per ottenere un consenso sociale decentralizzato sull'ordine e il contenuto di una serie di transazioni finanziarie crittograficamente firmate. I frutti di questo progetto, Bitcoin, fornirono una prima bozza di un registro delle transazioni decentralizzato.

Altri progetti costruiti sul successo del Bitcoin; le alt-coins hanno introdotto altre numerose monete attraverso la modifica del protocollo. Alcune delle più conosciute sono il Litecoin ed il Primecoin, discusse da \cite{sprankel2013technical}. Differenti progetti hanno tentato di prendere il valore del meccanismo principale del protocollo e di riproporlo; \cite{aron2012bitcoin} dibatte, per esempio, del Namecoin che è un progetto che ambisce a fornire un sistema di risoluzione dei nomi di dominio decentralizzato.

Ulteriori progetti tentano ancora di costruire all'apice del network proprio del Bitcoin, sfruttando la grande quantità di valore presente nel sistema ed il vasto ammontare di calcolo computazionale che è indirizzato nel meccanismo di consenso. Il progetto Mastercoin , proposto per la prima volta da \cite{mastercoin2013willett}, prova a dare vita ad un protocollo più ricco implementando molte caratteristiche aggiuntive di alto livello all'apice del protocollo Bitcoin attraverso l'utilizzo di un numero di parti ausiliarie al core del protocollo. Il progetto Coloured Coins, proposto da \cite{colouredcoins2012rosenfeld}, impiega una strategia simile ma più semplificata, arricchendo le regole di una transazione con il fine di fare a meno della valuta base del Bitcoin e permettere la creazione e il tracciamento dei tokens attraverso uno speciale ``chroma-wallet'' che è una parte del software chhe si interfaccia con il protocollo.

Ulteriore lavoro è stato fatto nel settore scartando l'assunto della decentralizzazione; Ripple, discusso da \cite{boutellier2014pirates}, ha cercato di creare un sistema ``federato'' per l'exchange di moneta, creando effettivamente uno nuovo sistema finanziario di clearing. Esso ha dimostrato che un miglioramento molto efficiente può essere ottenuto se la premessa della decentralizzazione viene tralasciata.

Il primo lavoro sugli smart contracts è stato fatto da \cite{szabo1997formalizing} e \cite{miller1997future}. Intorno al 1990 è divenuto chiaro che l'appilicazione agli accordi contrattuali di un sistema algoritmico può diventare una forza significativa nella cooperazione umana. Anche se non è stato proposto un sistema specificio per implementare il suddetto sistema, è stato ipotizzato che il futuro del sistema legale poteva essere pesantemente infulenzato da questo tipo di sistemi. Con questa premessa, Ethereum può essere una implementazione generale del suddetto \textit{crypto-law} sistema.

%E language?

\section{The Blockchain Paradigm} \label{ch:overview}

Ethereum, nel suo complesso, può essere visto come una macchina di stato basata sul sistema della transazione: abbiamo iniziato con uno stato di genesi che incrementalmente esegue le transazione con il fine di trasformarlo nello stato finale. In quest'ultimo, che noi accettiamo come la ``version'' canonica del mondo di Ethereum. Lo stato può includere la suddetta informazione come i saldi degli account, reputazioni, accordi fiduciari, dati relativi alle informazioni del mondo fisico; in breve, è ammissibile qualsiasi cosa che può essere rappresentata da un computer. Le transazioni, quindi, rappresentano un valido intervallo tra due stati; la parte `valida' è importante---esistono cambiamenti di stato di gran lunga più invalidi rispetto a quelli validi. I cambiamenti invalidi di stato potrebbero, \eg ad esempio essere cose come una riduzione del sanldo di un account senza un uguale ed opposto incremento altrove. Una valida transizione di stato è quella che avviene attraverso una transazione. Formalmente:
\begin{equation}
\boldsymbol{\sigma}_{t+1} \equiv \Upsilon(\boldsymbol{\sigma}_t, T)
\end{equation}

dove $\Upsilon$ è la funzione di transazione di stato di Ethereum. In Ethereum, $\Upsilon$, insieme a $\boldsymbol{\sigma}$ sono di gran lunga più efficaci che qualsiasi altro sistema comparabile; $\Upsilon$ consente ai componenti di trasportare una computazione arbitraria, mentre $\boldsymbol{\sigma}$ permette ai componenti di memorizzare uno stato arbitrario tra le transazioni.

Queste ultime sono collocate all'interno del blocchi; che sono concatenati l'uno con l'altro usando un hash crittografico come strumento di riferimento. La funzione dei blocchi come un giornale, che registra unitariamente una serie di transazioni con il blocco precedente e che funge da identificatore dello stato finale (anche se effettua se stesso lo storing dello stato ---in quanto sarebbe troppo grande). Essi hanno anche contraddistinto le serie della transazione con gli incentivi per i nodi per \textit{mine}. Questa incentivazione ha luogo come una funzione di trasizione di stato, aggiungendo valore all'account desginato.

Mining è il processo di dedicare uno sforzo computazione (working) per supportare una serie di transazioni (un blocco) rispetto ad un altro qualsiasi blocco in competizione. Esso è ottenuto grazie una prova crittografica sicura. Questo schema è conosciuto come proof-of-work ed è discusso in dettaglio nella sezione \ref{ch:pow}.

Formalmente, integriamo:
\begin{eqnarray}
\boldsymbol{\sigma}_{t+1} & \equiv & \Pi(\boldsymbol{\sigma}_t, B) \\
B & \equiv & (..., (T_0, T_1, ...) ) \\
\Pi(\boldsymbol{\sigma}, B) & \equiv & \Omega(B, \Upsilon(\Upsilon(\boldsymbol{\sigma}, T_0), T_1) ...)
\end{eqnarray}

Dove $\Omega$ è la funzione di transazione di stato della finalizzazione del blocco (una funzione che premia una parte designata); $B$ è il blocco, che include una serie di transazioni tra alcuni altri componenti; e $\Pi$ è il la funzione di transizione di stato del livello del blocco.

Questa è la base del paradigma blockchain, un modello che forma la spina dorsale non solo di Ethereum, ma di tutti i sistemi attuali decentralizzati basati sul consenso.

\subsection{Value}

Con il fine di incentivare la computazione attaverso il network, c'è bisongo di un metodo concordato per trasmettere valore. Per ottenere questo fine, Ethereum ha una moneta essenziale, Ether, conosciuta anche come {\small ETH} e a volte con riferimento all'inglese classico \DH{}. La più piccola subdenominazione di Ether, e quindi quello nel quale tutti i valori integri della moneta sono contati, è il Wei. Un Ether è definito come essere $10^{18}$ Wei. Esistono altre subdenominazioni di Ether:
\par
\begin{center}
\begin{tabular}{rl}
\toprule
Multiplier & Name \\
\midrule
$10^0$ & Wei \\
$10^{12}$ & Szabo \\
$10^{15}$ & Finney \\
$10^{18}$ & Ether \\
\bottomrule
\end{tabular}
\end{center}
\par

Attraverso il presente lavoro, qualsiasi riferimento al valore, nel contesto di Ether, moneta, un saldo o un pagamento, dovrebbe essere assunto di essere conteggiato in Wei.

\subsection{Which History?}

Dato che il sistema è decentralizzato e tutte le parti hanno un'opportunità di creare un nuovo blocco su qualche blocco più vecchio preestinte, la struttura risultante è necessariamente un "albero" di blocchi. Affinchè si formi un consenso su quale percorso, dalla radice (il blocco di genesi) fino alla foglia (il blocco che contiene le transazioni più recenti) attraverso questa struttura ad albero, conosciuto come blockchain, ci deve essere uno schema su cui ci sia un accordo. Se ci fosse mai un disaccordo tra i nodi su quale percorso, dalla radice alla foglia attraverso l'albero dei blocchi, sia la `migliore' blockchain, ciò comporterebbe \textit{fork} .

Questo significherebbe che nel passato rispetto ad un punto dato (blocco), potrebbero coesistere molteplici stati del sistema: qualche nodo potrebbe credere che un blocco contenga le canoniche transazioni, altri nodi invece che siano leggittimi altri blocchi, contenenti potenzialmente transazioni radicalmente differenti od incompatibili. Questo deve essere evitato a tutti i costi e l'invertezza che ne deriberebbe potrebbe probabilmente deteriore tutta la fiducia nell'intero sistema.

Lo schema che utilizziamo in ordine di generare consenso è una versione semplificata del protoccolo GHOST introdotto da \cite{cryptoeprint:2013:881}. Questo processo è descritto in dettaglio nella sezione \ref{ch:ghost}.

\section{Conventions}\label{ch:conventions}

Uso un numero di convenzioni tipografiche per la notazione formale, qualcuna delle quali è piuttosto presente nel presente scritto:

I due set dei molto strutturati, `top-level', valori di stato, sono denotati con lettere Greche in  grassetto minuscolo. Essi si dividono in quelli dello stato globale, che sono caratterizzati $\boldsymbol{\sigma}$ (od una varianteor a variant in merito) e quelli dello stato della macchina, $\boldsymbol{\mu}$.

Le funzioni operanti su valori molto strutturati sono indicati con una lettera greca maiuscola, \eg $\Upsilon$, la funzione di transizione di stato di Ethereum.

Per molte funzioni, una lettera maiuscola è usata, ad esempio $C$, la funzione generale del costo. Queste possono essere impiegate per denotare varianti specifiche, \eg $C_\text{\tiny SSTORE}$, la funzione del costo per l'operazione {\tiny SSTORE}. Per funzioni specifice e possibilmente definite esternamente, potrei impostare come testo della macchina da scrivere, \eg the Keccak-256 funzione di hash (come peril vincitore del contest SHA-3) è indicato $\texttt{KEC}$ (e riferito in in genere come il semplice Keccak). Anche $\texttt{KEC512}$ è riferito alla funzione di hash del Keccak 512.

Gli insiemi di dati sono tipicamente indicati con una lettera maiuscola, \eg $T$, è impiegata per caraterrizare una transazione Ethereum. Questo simbolo può, se definito di conseguenza, essere impiegato per rifersi ad una componente individuale, \eg $T_n$, denota il nonce di tale transazione. La forma del pedice è usato per indicare il proprio carattere; \eg gli apici si riferiscono agli insieme di dati con componenti indicabili.

Sequenze di byte scalari e di grandezza fissa (o, in modo analogo, matrici) sono caratterizzate con una normale lettera minuscola, \eg $n$ che è usata nel documento per denotare il nonce di una transazione. Quelle con un particolare specifico significato possono essere greche, \eg $\delta$, il numero degli oggetti richiesti sulla pila di una data operazione.

Sequenze di lunghezza arbitraria sono tipicamente indicata con una lettera minuscolo in grassetto, \eg $\mathbf{o}$ è impiegata per denotare la sequenza comei dati di output di un messaggio di chiamata. Per valori particolarmente importanti, un lettera in grassetto maiuscolo può essere usata.

Ovunque, assumiamo che gli scalari sono numeri interi positivi a quindi appartengono al set $\mathbb{P}$. Il set di tutte le sequenze di bytes è $\mathbb{B}$, formalmente definito in Appendice \ref{app:rlp}. Se un tale set di sequenze è limitato a quelli di una particolare lunghezza, è denotato con un pedice, perciò il set di tutte le sequenze di byte della lunghezza $32$ è nominato $\mathbb{B}_{32}$ ed il set di tutti i numeri intreri positivi più piccoli di $2^{256}$ è detto $\mathbb{P}_{256}$. Questo è formalmente definito nella sezione \ref{ch:block}.

Le parentesi quadre sono usate per indicizzare e riferirsi ai componenti individuali o sottosequenze di sequenze, \eg $\boldsymbol{\mu}_\mathbf{s}[0]$ denota il primo oggetto nella pila della macchina. Per sottosequenze, le ellissi sono impiegate per specificare ellipses are used to specify il range previsto, per includere elementi ad entrambi i limiti, \eg $\boldsymbol{\mu}_\mathbf{m}[0..31]$ denota i primi 32 oggetti della memoria della macchina.

Nel caso di uno stato globale $\boldsymbol{\sigma}$, che è una sequenza di account, essi stessi insieme di datithemselves tuples, le parentesi quadre sono impiegata per riferisi ad un account individuale.

Quando si considerano le varianti di valori esistenti, seguo la regola che entro un determinato campo per definizione, se assumiamo che un immodificato valore di `input' può essere indicato da un segnaposto $\Box$ quindi il valore utilizzato e modificabile è denotato come $\Box'$, e i valori intermedi sarebbero $\Box^*$,  $\Box^{**}$ \&c. In occasioni molto speciali, con il fine di massimizzare la leggibilità e solo in casi in cui il significato risulti essere non ambiguo, posso usare pedici alfanumeirci per indicare valori intermedi, soprattutto quelli di particolare rilievo.

Quando si considera l'uso di funzioni esistenti, data una funzione $f$, la funzione $f^*$ denota una simile, versione elemento per elemento della funzione di mapping anzichè tra sequenze. Esso è formalmente definito nella sezione \ref{ch:block}.

Definisco un numero di funzioni utili ovunque. Una delle più comuni è $\ell$, che valuta per l'ultimo elemento nella data sequenza:

\begin{equation}
\ell(\mathbf{x}) \equiv \mathbf{x}[\lVert \mathbf{x} \rVert - 1]
\end{equation}

\section{Blocks, State and Transactions} \label{ch:bst}

Avendo introdotto i concentti basici dietro Ethereum, discutereno il significato di una transazione, un blocco ed uno stato più nel dettaglio.

\subsection{World State} \label{ch:state}

Lo stato globale (\textit{state}), è una mappatura tra gli indirizzi (identificatori a 160-bit) e gli stati dell'account (una struttura di dati serializzata come RLP, vedere Appendix \ref{app:rlp}). Sebben non registrata sulla blockchain, si presume che l' implementazione manterrà questa mappatura in un albero Merkle Patricia modificato (\textit{trie}, si veda Appendix \ref{app:trie}). L'abero richiede un semplice database in backend che conserva la mappatura dei bytearrays ai bytearrays; nominiamo questo database sottostante il database di stato. Questo ha un numero di benefici; per primo il nodo alla base di questa struttura è crittograficamente dipendente nei confronti di tutti i dati interni ed in quanto tale il proprio hash può essere utilizzato come una identità sicura per l'intero sistema di stato. Secondariamente, essendo una struttura immutabile di dati, permette a qualunque stato precedente( il cui hash di radice è noto) di essere richiamato semplicimente alterando l'hash di root in base ad un accordo. Poichè prendiamo nota di tutti quesi hash di root nella blockchain, siamo capaci inventire in maniera banale i vecchi stati.

Lo stato dell'account comprende i quattro campi che seguomo:

\begin{description}
\item[nonce] Un valore scalare uguale al numero delle transazioni spedite da questo indirizzo o, nel caso di account con un codice associatom il numero di creazioni di contratto fatto da questo account. Per account di indirizzi $a$ nello stato $\boldsymbol{\sigma}$, questo potrebbe essere formalmente caratterizzato $\boldsymbol{\sigma}[a]_n$.
\item[balance] Un valore scalare uguale al numero di Wei posseduto da questo indirizzo. Formalmente denotato $\boldsymbol{\sigma}[a]_b$.
\item[storageRoot] Un hash a  256-bit del nodo di radice di un albero Merkle Patricia che codifica il contenuto in storage dell' account (una mappatura tra valori interi a 256-bit), condificati in una struttura come una mappatura dall'hash Keccak 256-bit delle chiavi a valori interi a 256-bit codificati in RLP. L'hash è formalmente caratterizzato $\boldsymbol{\sigma}[a]_s$.
\item[codeHash] L'hash del codice EVM code di questo account---questo è il codice che viene eseguito se questo indirizzo riceve un messaggio di chiamata; esso è immutabile e quindi, a differenza di tutti gli altri campi, non può essere cambiato dopo la sua compilazione. Tutti questi frammenti di condice sono contenuti nel database dello stato all'interno degli hash corrispondenti per il successivo recuperto. Questo hash è formalmente denotato $\boldsymbol{\sigma}[a]_c$, e per tanto il codice può essere indicato come $\mathbf{b}$, dato questo $\texttt{\small KEC}(\mathbf{b}) = \boldsymbol{\sigma}[a]_c$.
\end{description}

Dato che solitamente mi augro di riferirmi non all'hash della radice della struttura ma al sottostante set di coppie di chiave/valore memorizzate all'interno, definisco un'equivalenza conveniente:
\begin{equation}
\texttt{\small TRIE}\big(L_I^*(\boldsymbol{\sigma}[a]_\mathbf{s})\big) \equiv \boldsymbol{\sigma}[a]_s
\end{equation}

La funzione di crollo per il set delle coppie chiave/valore nella struttura, $L_I^*$, è definita come la trasformazione elemento per elemento della funzione di base $L_I$, data come:
\begin{equation}
L_I\big( (k, v) \big) \equiv \big(\texttt{\small KEC}(k), \texttt{\small RLP}(v)\big)
\end{equation}

dove:
\begin{equation}
k \in \mathbb{B}_{32} \quad \wedge \quad v \in \mathbb{P}
\end{equation}

Sarà compreso che $\boldsymbol{\sigma}[a]_\mathbf{s}$ non è il membro `fisico' dell'account e non contribuisce alla propria serializzazione successiva.

Se il \textbf{codeHash} campo è l'hash Keccak-256 della stringa vuota, ad es. $\boldsymbol{\sigma}[a]_c = \texttt{\small KEC}\big(()\big)$, quindi il nodo rappresenta un semplice account, qualche volta riferito come un account ``non-contratto''.

Perciò possiamo definire una funzione di collasso dello stato globale $L_S$:
\begin{equation}
L_S(\boldsymbol{\sigma}) \equiv \{ p(a): \boldsymbol{\sigma}[a] \neq \varnothing \}
\end{equation}
dove
\begin{equation}
p(a) \equiv  \big(\texttt{\small KEC}(a), \texttt{\small RLP}\big( (\boldsymbol{\sigma}[a]_n, \boldsymbol{\sigma}[a]_b, \boldsymbol{\sigma}[a]_s, \boldsymbol{\sigma}[a]_c) \big) \big)
\end{equation}

Questa funzione, $L_S$, viene utilizzata insieme alla funzione di struttura per fornire una breve identità (hash) dello stato globalew. Noi riteniamo:
\begin{equation}
\forall a: \boldsymbol{\sigma}[a] = \varnothing \; \vee \; (a \in \mathbb{B}_{20} \; \wedge \; v(\boldsymbol{\sigma}[a]))
\end{equation}
dove $v$ è la funzione di validità dell'account:
\begin{equation}
\quad v(x) \equiv x_n \in \mathbb{P}_{256} \wedge x_b \in \mathbb{P}_{256} \wedge x_s \in \mathbb{B}_{32} \wedge x_c \in \mathbb{B}_{32}
\end{equation}

\subsection{The Transaction} \label{ch:transaction}

Una transazione (formalmente, $T$) è una singola instruzione, firmata crittograficamente dall'esterno verso l'ambiente di Ethereum. Mentre si presume che l'ultimo attore esterno sarà un essere umano, gli strumenti software saranno impiegati nella sua propria costruzione e diffusione\footnote{Notably, come `strumenti' potrebbero alla fine diventare così semplici da non necessitare l'iniziativa dell'essere umano--o gli umani possono diventare occanasionalmente imparziali---che ci potrebbe assere un punto che ci potrebbe essere un punto in cui essi potrebbero giustamente essere considerati agenti autonomi. \eg i contratti possono offire ricompense agli umani per al fine di inviare transazioni per iniziare la loro esecuzione.}. Ci sono due tipi di transazioni: quelle che danno luogo a chiamate di messaggi e quelle che derivano dalla creazione di nuovi account con il codice associato (conosciuto informalmente come `creazione del contratto'). Entrambi i tipi specificano un numero di campi in comune:

\begin{description}
\item[nonce] Un valore scalare uguale al numero delle transazioni inviate dal mittente; formalmente $T_n$.
\item[gasPrice] Un valore scalare uguale al numero di Wei da pagare per unità di \textit{gas} per tutti i costi computazionali occorsi come risultato dell'esecuzione di questa transazione; formalmente $T_p$.
\item[gasLimit] Un valore scalare uguale al massimo ammontare di gas che dovrebbe essere usato in esecuzione di questa transazione. Questo è pagato in anticipo, prima che qualsiasi computazione si effettuato e non può essere incrementato in seguito; formalmente $T_g$.
\item[to] L'indirizzo a 160-bit del messaggio di chiamata del destinatario o, per una transazione della creazione di un contratto, $\varnothing$, usato qui per indicare l'univo membro di $\mathbb{B}_0$ ; formalmente $T_t$.
\item[value] Un valore scalare uguale al numero di Wei da trasferire alla messaggio di chiamata del destinatario o, nel caso della creazione del contratto, come un assegnazione all'account di nuova creazione; formalmente $T_v$.
\item[v, r, s] I valori corrispondenti alla firma della transazione ed usato per determinare il mittente della transazione; formalmente $T_w$, $T_r$ e $T_s$. Questo è apprfondtio nell' Appendix \ref{app:signing}.
\end{description}

In più, una transazione che crea un contratto:

\begin{description}
\item[init] Un insieme di dati di grandezza illimitata specificando che il codice EVM per la procedura di inizializzazione dell'account, formalmente $T_\mathbf{i}$.
\end{description}

\textbf{init} è un frammento di codice EVM; esso da come risultato il \textbf{body}, un secondo frammento di codice che viene eseguito ogni volta l'account riceve un messaggio di chiamata (sia attraverso una transazione o per l'esecuzione interna del codice). \textbf{init} è eseguito solo quando l'account è creato ed viene scartato subito dopo.

Al contrario, una transazione tramite messaggio di chiamata contiene:

\begin{description}
\item[data] Un insieme di data di grandezza illimitata in byte che specifica i dati di input del messaggio di chiamata, formalmente $T_\mathbf{d}$.
\end{description}

Appendix \ref{app:signing} specifica la funzione, $S$, che mappa le transazioni del mittente, ed accade attraverso l'ECDSA della curva SECP-256k1, usando l'hash della transazione (eccetto gli ultimi tre campi per la firma) come il dato per firmare. Per adesso noi semplicemente asseriamo che il mittente di una data transazione $T$ può essere rappresentato con $S(T)$.

\begin{equation}
L_T(T) \equiv \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}, T_w, T_r, T_s) & \text{if} \; T_t = \varnothing\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}, T_w, T_r, T_s) & \text{otherwise} 
\end{cases}
\end{equation}

Qua, ipotizziamo che tutte le componenti sono interpretate dall'RLP come valori interi, con l'eccezione della lunghezza arbitraria , in byte, dell'inzieme di dati $T_\mathbf{i}$ and $T_\mathbf{d}$.
\begin{equation}
\begin{array}[t]{lclclc}
T_n \in \mathbb{P}_{256} & \wedge & T_v \in \mathbb{P}_{256} & \wedge & T_p \in \mathbb{P}_{256} & \wedge \\
T_g \in \mathbb{P}_{256} & \wedge & T_w \in \mathbb{P}_5 & \wedge & T_r \in \mathbb{P}_{256} & \wedge \\
T_s \in \mathbb{P}_{256} & \wedge & T_\mathbf{d} \in \mathbb{B} & \wedge & T_\mathbf{i} \in \mathbb{B}
\end{array}
\end{equation}
where
\begin{equation}
\mathbb{P}_n = \{ P: P \in \mathbb{P} \wedge P < 2^n \}
\end{equation}

L'hash dell'indirizzo $T_\mathbf{t}$ è leggermente diverso: è sia un hash di uni indirizzo a 20-byte address hash o, nel caso sia una transazione che crei un contratto (e quindi formalmente uguale a $\varnothing$), è una serie vuota di dati RLP e perciò il membro di $\mathbb{B}_0$:
\begin{equation}
T_t \in \begin{cases} \mathbb{B}_{20} & \text{if} \quad T_t \neq \varnothing \\
\mathbb{B}_{0} & \text{otherwise}\end{cases}
\end{equation}

\subsection{The Block} \label{ch:block}

Il blocco in Ethereum è l'insieme delle componenti di informazione (conosciuto come il blocco \textit{header}), $H$, insieme con l'informazione corrispondente alle transazioni incluse, $\mathbf{T}$, ed un set delle intestanzioni dell'altro blocco $\mathbf{U}$ che è conosciuto per avere un genitore guale al genitore dell'attuale RIVEDERE QUIthat are known to have a parent equal to the present block's parent's parent RIVEDERE QUI(questi blocchi sono conosciuti come \textit{ommers}\footnote{\textit{ommer} è il più prevalenteis the most prevalent (non dice molto) termine generico neutrale per dire ``fratello del genitore''; si veda \url{http://nonbinary.org/wiki/Gender_neutral_language#Family_Terms}}). L'intestazione del blocco contiene diverse parti di informazione:

%\textit{TODO: Introduce logs}

\begin{description}
\item[parentHash] L'hash Keccak 256-bit dell'intestazione del blocco genitore, nella sua interezza; formalmente $H_p$.
\item[ommersHash] L'hash Keccak 256-bit hash RIVEDI QUA of the ommers list portion of this block; formally $H_o$.
\item[beneficiary] L'indirizzo a 160-bit presso cui sono raccolte tutte le commissioni del mining di questo blocco da trasferire; formalmente $H_c$.
\item[stateRoot] L'hash Keccak 256-bit del nodo madre della struttura dello stato, dopo tutto le transazioni vengono eseguite e applicate le finalizzazioni; formalmente $H_r$.
\item[transactionsRoot] L'hash 256-bit del nodo alla radice della struttura hash al cui interno ci sono immaganizzati ogni transazione nella porzione della lista delle transazioni del blocco; formalmente $H_t$.
\item[receiptsRoot] L'hash Keccak 256-bit del nodo alla radice della struttura con le ricevute di ogni transazione nella porzione della lista delle transazioni del blocco; formalmente $H_e$.
\item[logsBloom] Il filtro Bloom composto da informazioni indicizzabili (l'indirizzo del logger ed i log topics) contenuto in ogni log entry dalla ricevuta di ogni transazione nella lista delle transazioni; formalmente $H_b$.
\item[difficulty] Un valore scalare corrispondente al livello di difficoltà di questo blocco. Questo può essere calcolato dal livello di difficoltà del precedente blocco e dalla marca temporale; formalmente $H_d$.
\item[number] Un valore scalare uguale al numero dei blocchi antenati. Il blocco di genesi ne ha un numero pari a zero; formalmente $H_i$.
\item[gasLimit] Un valore scalare uguale al limite di spesa del gas per blocco; formalmente $H_l$.
\item[gasUsed] Un valore scalare uguale al gas totale usato nelle transazioni di questo blocco; formalmente $H_g$.
\item[timestamp] Un valore scalare uguale al ragionevole tempo() di outpout di Unix alla nascita di questo blocco; formalmente $H_s$.
\item[extraData] Un insieme di dati arbitrario contenete dati rilevanti per questo blocco. Questo deve essere di 32 bytes o meno; formalmente $H_x$.
\item[mixHash] Un hash a 256-bit che prova che hash che dimostra insieme al nonce che un sufficiente ammontare di computazione è stato convogliato per mezzo di questo blocco; formalmente $H_m$.
\item[nonce] Un hash a 64-bit che dimostra che insieme con il mix-hash, che un ammontare sufficiente di computazione è stato convogliato per mezzo di questo blocco; formalmente $H_n$.
\end{description}

Gli altri due componenti nel blocco sono semplicemente una lista di intestazioni di blocchi OMMER RIVEDERE QUA (dello stesso formato di cui sopra) e una serie di transazioni. Formalmente, siamo in grado di fare riferimento ad un blocco $B$:
\begin{equation}
B \equiv (B_H, B_\mathbf{T}, B_\mathbf{U})
\end{equation}

\subsubsection{Transaction Receipt}

Con il fine di codificare l'informazione circa ad una transazione, riguardo alla quale può essere utile costituire una prova a conoscenza zero, o indice e ricerca, codifichiamo una ricevuta di ogni transazione contenente certe informazioni che attengono la propria esecuzione. Ogni ricevuta, indicata $B_\mathbf{R}[i]$ per la $i$th transaction) è posizionata in una struttura a indice e chiave e la struttura base viene memorizzata nell'intestazione come $H_e$.

La ricevuta della transazione è un insieme di dati di quattro oggetti compreso lo stato successivo la transazione, $R_{\boldsymbol{\sigma}}$, il gas complessivo usato nel blocco che contiene la ricevuta della transazione nel momento immediatamente successivo a quello in cui la transazione avviene $R_u$, il set di lot creato attraverso l'esecuzione della transazione, $R_\mathbf{l}$ ed il filtro Bloom formato attraverso l'informazioni in quei logs, $R_b$:
\begin{equation}
R \equiv (R_{\boldsymbol{\sigma}}, R_u, R_b, R_\mathbf{l})
\end{equation}

La funzione $L_R$ prepara semplicemente una ricveuta della transazione per essere trasformata in un insieme di dati serializzati in byte RLP:
\begin{equation}
L_R(R) \equiv (\mathtt{\small TRIE}(L_S(R_{\boldsymbol{\sigma}})), R_u, R_b, R_\mathbf{l})
\end{equation}
quindi lo stato successivo alla transazione, $R_{\boldsymbol{\sigma}}$ è codificato in una struttura ad albero, la cui radice costituisce il primo elemento.

Affermiamo $R_u$, il gas complessivo impiegato come un numero intero positivo e che permette il log di Bloom, $R_b$, è un hash di grandezza a 2048 bits (256 bytes):
\begin{equation}
R_u \in \mathbb{P} \quad \wedge \quad R_b \in \mathbb{B}_{256}
\end{equation}

%Notably $B_\mathbf{T}$ does not get serialised into the block by the block preparation function $L_B$; it is merely a convenience equivalence.

Le voci nel log, $R_\mathbf{l}$, sono una serie di informazioni presenti nel log, definite, per esempio, $(O_0, O_1, ...)$. Una voce nel log, $O$, è un insieme di dati dell'indirizzo di chi effettua il log, $O_a$, una serie di topics del log a 32-bytes, $O_\mathbf{t}$ e un po' di bytes di dati, $O_\mathbf{d}$:
\begin{equation}
O \equiv (O_a, ({O_\mathbf{t}}_0, {O_\mathbf{t}}_1, ...), O_\mathbf{d})
\end{equation}
\begin{equation}
O_a \in \mathbb{B}_{20} \quad \wedge \quad \forall_{t \in O_\mathbf{t}}: t \in \mathbb{B}_{32} \quad \wedge \quad O_\mathbf{d} \in \mathbb{B}
\end{equation}

Definiamo la funzione del filtro Bloom, $M$, per ridurre una voce nel log che include un hash a 256-byte hash:
\begin{equation}
M(O) \equiv \bigvee_{t \in \{O_a\} \cup O_\mathbf{t}} \big( M_{3:2048}(t) \big)
\end{equation}

dove $M_{3:512}$ è un filtro Bloom specializzato che imposta tre bit al di fuori di 2048, dando una serie arbitraria di dati. Fa questo prendendo gli 11 bit di basso ordine delle prime tre coppie di byte in hash Keccak 256 della serie di dati. Formalmente:
\begin{eqnarray}
M_{3:2048}(\mathbf{x}: \mathbf{x} \in \mathbb{B}) & \equiv & \mathbf{y}: \mathbf{y} \in \mathbb{B}_{256} \quad \text{where:}\\
\mathbf{y} & = & (0, 0, ..., 0) \quad \text{except:}\\
\forall_{i \in \{0, 2, 4\}}&:& \mathcal{B}_{m(\mathbf{x}, i)}(\mathbf{y}) = 1\\
m(\mathbf{x}, i) &\equiv& \mathtt{\tiny KEC}(\mathbf{x})[i, i + 1] \bmod 2048
\end{eqnarray}

dove $\mathcal{B}$ è la funzione di riferimento tale che $\mathcal{B}_j(\mathbf{x})$ equivale al bit dell'indice $j$ (indicizzato da 0) nell'insieme di byte $\mathbf{x}$.

\subsubsection{Holistic Validity}

Possiamo affermare che la validità del blocco se e solo se soddisfa diverse condizioni: deve essere internamente coerente con l'ommer e gli hash della transazione del blocco a date transazioni $B_\mathbf{T}$ (come specificato in sec \ref{ch:finalisation}), dove eseguito in ordine nella base dello stato $\boldsymbol{\sigma}$ (derivato dallo stato finale del blocco genitore), risulta in un nuovo stato dell'identità $H_r$:
\begin{equation}
\begin{array}[t]{lclc}
H_r &\equiv& \mathtt{\small TRIE}(L_S(\Pi(\boldsymbol{\sigma}, B))) & \wedge \\
H_o &\equiv& \mathtt{\small KEC}(\mathtt{\small RLP}(L_H^*(B_\mathbf{U}))) & \wedge \\
H_t &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{T} \rVert, i \in \mathbb{P}: p(i, L_T(B_\mathbf{T}[i]))\}) & \wedge \\
H_e &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{R} \rVert, i \in \mathbb{P}: p(i, L_R(B_\mathbf{R}[i]))\}) & \wedge \\
H_b &\equiv& \bigvee_{\mathbf{r} \in B_\mathbf{R}} \big( \mathbf{r}_b \big)
\end{array}
\end{equation}

dove $p(k, v)$ è semplicemente le coppie di trasformazione RLP, in questo caso, la prima è l'indice della transazione nel blocco e la seconda la ricevuta:
\begin{equation}
p(k, v) \equiv \big( \mathtt{\small RLP}(k), \mathtt{\small RLP}(v) \big)
\end{equation}

Inoltre:
\begin{equation}
\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma})) = {P(B_H)_H}_r
\end{equation}

Quindi $\texttt{\small TRIE}(L_S(\boldsymbol{\sigma}))$ è l'hash del nodo radice della struttutra Merkle Patricia tree contenente le coppie chiave-valore dello stato $\boldsymbol{\sigma}$ con i valori condificati usando RLP, e $P(B_H)$ è il blocco genitore di $B$, definito in maniera diretta.

I valori derivanti dalla computazione delle transazioni, specificatamente dalle ricevute delle transazioni, $B_\mathbf{R}$, e che sono definite attraverso la funzione di aumento di stato delle transazioni, $\Pi$, sono formalizzate più avanti nella sezione \ref{sec:statenoncevalidation}.

\subsubsection{Serialisation}

Le funzioni $L_B$ e $L_H$ sono quelle preparatorie rispettivamente per un blocco e per l'intestazione di un blocco. In maniera del tutto simile la funzione di preparazione della ricevuta della transazione $L_R$, sosteniamo i tipi e l'ordine della struttura per quando la trasformazione RLP è richiesta:
\begin{eqnarray}
\quad L_H(H) & \equiv & (\begin{array}[t]{l}H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d,\\ H_i, H_l, H_g, H_s, H_x, H_m, H_n \; )\end{array} \\
\quad L_B(B) & \equiv & \big( L_H(B_H), L_T^*(B_\mathbf{T}), L_H^*(B_\mathbf{U}) \big)
\end{eqnarray}

Con $L_T^*$ e $L_H^*$ che sono sequenze di trasformazione elemento per elemento, perciò:
\begin{equation}
f^*\big( (x_0, x_1, ...) \big) \equiv \big( f(x_0), f(x_1), ... \big) \quad \text{for any function} \; f
\end{equation}

Quindi i tipi di componente sono definiti:
\begin{equation}
\begin{array}[t]{lclclcl}
H_p \in \mathbb{B}_{32} & \wedge & H_o \in \mathbb{B}_{32} & \wedge & H_c \in \mathbb{B}_{20} & \wedge \\
H_r \in \mathbb{B}_{32} & \wedge & H_t \in \mathbb{B}_{32} & \wedge & H_e \in \mathbb{B}_{32} & \wedge \\
H_b \in \mathbb{B}_{256} & \wedge & H_d \in \mathbb{P} & \wedge & H_i \in \mathbb{P} & \wedge \\
H_l \in \mathbb{P} & \wedge & H_g \in \mathbb{P} & \wedge & H_s \in \mathbb{P}_{256} & \wedge \\
H_x \in \mathbb{B} & \wedge & H_m \in \mathbb{B}_{32} & \wedge & H_n \in \mathbb{B}_{8}
\end{array}
\end{equation}

dove
\begin{equation}
\mathbb{B}_n = \{ B: B \in \mathbb{B} \wedge \lVert B \rVert = n \}
\end{equation}

Sappiamo che abbiamo una rigorosa specifica per la costruzione di una struttura formale di un blocco. La funzione RLP $\texttt{\small RLP}$ (see Appendix \ref{app:rlp}) fornisce il metodo canonico per la trasformazione di questa struttura in una sequenza di byte pronta per la trasmissione attraverso la rete o o conservati localmente.

\subsubsection{Block Header Validity}

Definiamo $P(B_H)$ essere il blocco genitore di $B$, formalmente:
\begin{equation}
P(H) \equiv B': \mathtt{\tiny KEC}(\mathtt{\tiny RLP}(B'_H)) = H_p
\end{equation}

Il numero del blocco è il numero del blocco genitore incrementato di uno:
\begin{equation}
H_i \equiv {{P(H)_H}_i} + 1
\end{equation}

La difficoltà canonica di un blocco dell'intestazione $H$ è definita come $D(H)$:
\begin{equation}
D(H) \equiv \begin{cases}
131072 & \text{if} \quad H_i = 0\\
{P(H)_H}_d + \left\lfloor\frac{{P(H)_H}_d}{2048}\right\rfloor & \text{if} \quad H_s < {P(H)_H}_s + 13\\
\max \{ 131072, x \} & \text{otherwise}\\
\end{cases}
\end{equation}
where:
\begin{equation}
x = {P(H)_H}_d - \left\lfloor\frac{{P(H)_H}_d}{2048}\right\rfloor
\end{equation}

Il limite del gas standard $H_l$ di un blocco dell'intestazione $H$ deve soddisfare la relazione:
\begin{eqnarray}
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l \geqslant 5000
\end{eqnarray}

$H_s$ è la marca temporale del blocco $H$ e deve soddisfare la relazione:
\begin{equation}
H_s > {P(H)_H}_s
\end{equation}

Questo meccanismo fa rispettare una omeostasi in termini del tempo tra i blocchi; un periodo inferiore tra gli ultimi due blocchi comporta in un incremento del livello di difficoltà e quindi è richiesta una computazione aggiuntivae, che allunga verosimilmente il periodo successivo. Al contrario, se il periodo è troppo grande, la difficoltà, ed il tempo atteso per il prossimo blocco, si riducono.

Il nonce, $H_n$, deve soddifare le relazioni:
\begin{equation}
n \leqslant \frac{2^{256}}{H_d} \quad \wedge \quad m = H_m
\end{equation}
with $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$.

Dove $H_{\hcancel{n}}$ è la nuova intestazione del blocco $H$, ma \textit{without} il nonce e i componenti mix-hash, $\mathbf{d}$ essendo l'attuale DAG, un grande set di dati necessari per calcolare il mix-hash, e $\mathtt{PoW}$ è la funzione proof-of-work (si veda la sezione \ref{ch:pow}): questo restituisce un insieme di dati con il primo elemento che è un the mix-hash, al fine di provare che un corretto DAG sia stato utilizzato, ed il secondo elemento che è un numero crittografico pseudo randomico che dipende da $H$ e $\mathbf{d}$. Avendo dato grossomodo una distribuzione uniforme nel range $[0, 2^{64})$, il tempo atteso per trovare una soluzione è proporzionale alla difficoltà, $H_d$.

Questo è il fondamento della sicurezza della blockchain e la ragione fondamentale perchè un nodo malevolo non possa propagare blocchi di nuova creazione che altrimenti sovrascrivebbero (``rewrite'') i precedenti. Poichè il nonce deve soddisfare il requisito, e poichè la sua soddisfazione dipende dai contenti del blocco e a sua volta le sue operazioni composte, RIVEDI QUA creando nuovi, validi, blocchi è difficile e, con il tempo, necessita apprositivamente la potenza computazionale totale della parte fidata dei peers del mining.

Quindi possiamo definire la funzione di validità dell'intestazione del blocco $V(H)$:
\begin{eqnarray}
V(H) & \equiv &  n \leqslant \frac{2^{256}}{H_d} \wedge m = H_m \quad \wedge \\
& & H_d = D(H) \quad \wedge \\
& & H_g \le H_l  \quad \wedge \\
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l \geqslant 125000  \quad \wedge \\
& & H_s > {P(H)_H}_s \quad \wedge \\
& & H_i = {P(H)_H}_i +1 \quad \wedge \\
& & \lVert H_x \rVert \le 32
\end{eqnarray}
where $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$

E' sufficiente che \textbf{extraData} contenga almeno 32 byte.

\section{Gas and Payment} \label{ch:payment}

Con il fine di evitare problemi relativi all'abuso del network e per aggirare le inevitabili derivanti della completezza di Turing, tutta la computazione programmabile in Ethereum è soggetta alla fee. Il tariffario è specificato in unità di \textit{gas} (see Appendix \ref{app:fees} per le fee associate con le diverse computazioni. Perciò ogni dato frammento di computazione programmabile (questo include la creazione di contratti, fare messaggi di chiamata, utilizzando ed accedendoo all'account di storage ed eseguendo operazioni sulla macchina virtuale) ha un costo universalmente accettato in termi di gas.

Ogni transazione ha uno specifico ammontare di gas con cui è associata: \textbf{gasLimit}. Questo è l'ammontare del gas che è acquistato implicitamente attraverso il saldo dell'account del mittente. L'acquisto avviene al pattuito \textbf{gasPrice}, anche specificato nella transazione. La transazione è considerata invalida se il saldo dell'account non può sostenere il suddetto acquisto. Prende il nome di \textbf{gasLimit} poichè ogni gas inutilizzato alla fine della transazione è restituito (allo stesso prezzo dell'acquisto) all'account del mittente. Il Gas non esiste al di guori dell'esecuzione di una transazione. Quindi per gli account con un codice associato di cui si ha fiducia, può essere impostato un limite di gas relativalemnte alto senza la necessità di modificarlo.

In generale, l'Ether impiegato per acquistare il gas che non è rimborsabile è consegnato al \textit{beneficiary} dell'indirizzo, che è tipicamente sotto il controllo del miner. Coloro che effettuano le transazioni sono liberi di specificare qualsiasi are free to specify any \textbf{gasPrice} che desiderano, tuttavia i miner sono liberi di ignorare le transazioni da loro scelte. Un prezzo più alto del prezzo del gas per una transazione dunque costerà di più al mittente in termini di Ether e consegnerà un valore più grande al miner e quindi avrà più possibilità di essere selezionato al fine di essere incluso da più miner. In generale, i Miner sceglieranndi promuovere il prezzo minimo del gas per il quale essi daranno esecuzione alla transazioni e coloro che effettuano le transazioni saranno liberi di analizzare a fondo questi prezzi per determinare il prezzo del gas da offrire. Poichè ci sarà una (ponderata) distribuzione del minmo prezzo del gas accettabile, coloro che eseguno le transazioni dovranno necessariamente accettare un compromesso tra diminuire il prezzo del gas e massimizzare la chance che la loro transazione sarà "minata" tempestivamente.

%\subsubsection{Determining Computation Costs}

\section{Transaction Execution} \label{ch:transactions}

L'esecuzione di una transazione è la parte più complessa del protocollo Ethereum: essa definisce la funzione di transizione di stato $\Upsilon$. Si presume che qualsiasi transazioni eseguita superi i test iniziali di validità intrinseca. Questi includono:

\begin{enumerate}
\item La transazione è un RLP ben strutturata, con nessun ulteriore byte;
\item la firma della transazione è valida;
\item il nonce della transazione è valido (equivalnte al nonce attuale dell'account del mittente);
\item il limite del gas non è inferiore al gas intrinseco, $g_0$, impiegato dalla transazione;
\item il saldo dell'account del mittente contiene almeno il costo, $v_0$, richiesto dal pagamento anticipato.
\end{enumerate}

Formalmente, consideriamo la funzione $\Upsilon$, con $T$ che è una transazione e $\boldsymbol{\sigma}$ lo stato:
\begin{equation}
\boldsymbol{\sigma}' = \Upsilon(\boldsymbol{\sigma}, T)
\end{equation}

Quindi $\boldsymbol{\sigma}'$ è lo stato successivo alla transazione. Definiamo anche $\Upsilon^g$ per valutare l'ammontare di gas usato nell'esecuzione di una transazione e $\Upsilon^\mathbf{l}$ per stimare gli oggetti accumalati nel log della transazione, entrambi definiti successivamente.

\subsection{Substate}
Attraverso l'escuzione della transazione, noi accomuliamo certe informazioni RIVEDI QUA that is acted upon immediately following the transaction. Chiamiamo questo \textit{transaction substate}, e rappresentiamo questo come $A$, che è un insieme di dati:
\begin{equation}
A \equiv (A_\mathbf{s}, A_\mathbf{l}, A_r)
\end{equation}

I contenuti dell'insieme di dati includono $A_\mathbf{s}$, il set suicidio: un set di account che saranno scartati a seguito del completamento della transazione. $A_\mathbf{l}$ è il log della serie: si tratta di una serie di `checkpoints' archiviati ed indicizzabili nell'esecuzione del codice VM che permette alle chiamate-contratto di essere monitorate da osservatori esterni al mondo di Ethereum (come alle interfacce di un'applicazione decentralizzata). Infine c'è $A_r$, il saldo di rimborso, incrementato attraverso l'uso dell'istruzione {\small SSTORE} con il fine di eseguire il riavvio del contratto di storage a zero da qualche valore diverso da zero. Anche se non immediatamente rimborsati, è consentito di compensare parzialmente i costi totali dell'esecuzione.

Per brevità, definiamo il sottostato vuoto $A^0$ non avere suicidi, nessun log e zero saldo di rimborso:
\begin{equation}
A^0 \equiv (\varnothing, (), 0)
\end{equation}

\subsection{Execution}
Definiamo il gas intrinseco $g_0$, l'ammontare di gas che questa transazione richiede di versare prima dell'esecuzione, come segue:
\begin{equation}
g_0 \equiv \sum_{i \in T_\mathbf{i}, T_\mathbf{d}} \begin{cases} G_{txdatazero} & \text{if} \quad i = 0 \\ G_{txdatanonzero} & \text{otherwise} \end{cases} + G_{transaction}\\
\end{equation}

dove $T_\mathbf{i},T_\mathbf{d}$ significa la serie di byte dei dati associati alla transazione ed inizializzati con un codice EVM, a seconda che la transazione sia per una creazione di un contratto o per una chiamata di un messaggio. $G$ è definito in Appendix \ref{app:fees}.

%todo Explain g_d reason?

Il costo anticipato $v_0$ è calcolato come:
\begin{equation}
v_0 \equiv T_g T_p + T_v
\end{equation}

La validità è derminata come:
\begin{equation}
\begin{array}[t]{rcl}
S(T) & \neq & \varnothing \quad \wedge \\
\boldsymbol{\sigma}[S(T)] & \neq & \varnothing \quad \wedge \\
T_n & = & \boldsymbol{\sigma}[S(T)]_n \quad \wedge \\
g_0 & \leqslant & T_g \quad \wedge \\ 
v_0 & \leqslant & \boldsymbol{\sigma}[S(T)]_b \quad \wedge \\
T_g & \leqslant & {B_H}_l - \ell(B_\mathbf{R})_u
\end{array}
\end{equation}

Si noti la condizione finale; la somma del limite del gas della transazione, $T_g$, ed il gas utilizzato in precedenza in questo bloccoa, dato da $\ell(B_\mathbf{R})_u$, non deve essere maggiore del \textbf{gasLimit}, ${B_H}_l$ del blocco. 

L'esecuzione di una transazione valida inizia con il cambio irrevocabile fatto allo stato: il nonce dell'account del mittente, $S(T)$, è incrementato di uno e il saldo è ridotto dal costo anticipato, $v_0$. Il gas disponibile per il procedere della computazione, $g$, è definito come $T_g - g_0$. La computazione, sia la creazione di un contratto o la chiamata di un messaggio, risulta in uno stato eventuale (che può essere legalmente equivalente allo stato attuale), il cambiamento a cui è deterministico e mai invalido: non ci possono essere transazioni valide da questo punto.

Definiamo lo stato checkpoint $\boldsymbol{\sigma}_0$:
\begin{eqnarray}
\boldsymbol{\sigma}_0 & \equiv & \boldsymbol{\sigma} \quad \text{except:} \\
\boldsymbol{\sigma}_0[S(T)]_b & \equiv & \boldsymbol{\sigma}[S(T)]_b - T_g T_p \\
\boldsymbol{\sigma}_0[S(T)]_n & \equiv & \boldsymbol{\sigma}[S(T)]_n + 1
\end{eqnarray}

Valutando $\boldsymbol{\sigma}_P$ da $\boldsymbol{\sigma}_0$ dipende dal tipo di transazione; sia la creazione di un contratto che il messaggio di chiamata; definiamo l'insieme di dati dello stato provvisorio di post esecuzione $\boldsymbol{\sigma}_P$, il gas rimanente $g'$ ed il sottostato $A$:
\begin{equation}
(\boldsymbol{\sigma}_P, g', A) \equiv \begin{cases}
\Lambda(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad g, T_p, T_v, T_\mathbf{i}, 0) & \text{if} \quad T_t = \varnothing \\
\Theta_{3}(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad T_t, T_t, g, T_p, T_v, T_\mathbf{d}, 0) & \text{otherwise}
\end{cases}
\end{equation}

dove $g$ è l'ammontare di gas rimamente dopo la sottrazione dell'ammonatare basico necessario per pegare affinchè una transazione avvenga:
\begin{equation}
g \equiv T_g - g_0
\end{equation}
e $T_o$ colui che effettua la transazione in origine, che può differire dal mittente nel caso in cui un messaggio di chiamata o la creazione di un contratto non derivino direttamente da una transazione ma pervengano dall'esecuzione di un codice EVM.

Si noti che usiamo $\Theta_{3}$ per indicare il fatto che solo i primi tre componenti del valore della transazione sono impiegati; il finale rappresenta il valore di outopout del messaggio di chiamata (un insieme di dati) e non è impiegato nel contesto della valutaziona delle transazione.

Dopo il messaggio di chiamata o dopo che la creazione di un contratto è processata, lo stato è finalizzato determinando l'ammontare da rifondere, $g^*$ dal gas rimanente, $g'$, più qualche somma dal contantore del rimborso, al mittente al tasso originale.
\begin{equation}
g^* \equiv g' + \min \{ \Big\lfloor \dfrac{T_g - g'}{2} \Big\rfloor, A_r \}
\end{equation}

L'ammontare totale rimborsabile è il gas che rimane legittimamente $g'$, addizionato a $A_r$, con quest'ultimo componente che è limitato fino al massimo di metà (arrotondato per difetto) del totale dell'ammontate impiegato $T_g - g'$.

L'Ether per il gas è dato ai miner, i cui indirizzi sono specificati come i benificiari del blocco attuale $B$. Così definiamo lo stato precedente al finale $\boldsymbol{\sigma}^*$ in termini di stato provvisorio $\boldsymbol{\sigma}_P$:
\begin{eqnarray}
\boldsymbol{\sigma}^* & \equiv & \boldsymbol{\sigma}_P \quad \text{except} \\
\boldsymbol{\sigma}^*[S(T)]_b & \equiv & \boldsymbol{\sigma}_P[S(T)]_b + g^* T_p \\
\boldsymbol{\sigma}^*[m]_b & \equiv & \boldsymbol{\sigma}_P[m]_b + (T_g - g^*) T_p \\
m & \equiv & {B_H}_c
\end{eqnarray}

Lo stato finale, $\boldsymbol{\sigma}'$, è raggiunto dopo che sono elimitati tutti gli account che appaiono nella lista suicidio:
\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}^* \quad \text{except} \\
\forall i \in A_\mathbf{s}: \boldsymbol{\sigma}'[i] & \equiv & \varnothing
\end{eqnarray}

E alla fine, specifichiamo $\Upsilon^g$, il gas totale utilizzato in questa transazione e $\Upsilon^\mathbf{l}$, i log creati da questa transazione:
\begin{eqnarray}
\Upsilon^g(\boldsymbol{\sigma}, T) & \equiv & T_g - g' \\
\Upsilon^\mathbf{l}(\boldsymbol{\sigma}, T) & \equiv & A_\mathbf{l}
\end{eqnarray}

Questi sono usati per aiutare a definire la ricevuta della transazione, discussa più tardi.

%In the case that $s = m$ then we simply return the Ether back to the sender/miner, collapsing the exception into:
%\begin{eqnarray}
%\boldsymbol{\sigma}'[s]_b & \equiv & \boldsymbol{\sigma}_P[s]_b + g
%\end{eqnarray}

\section{Contract Creation} \label{ch:create}

C'è un numero di parametri intrinseci impiegati quando viene creato un account: mittente ($s$), colui che effettua per primo la transazione ($o$), gas disponibile ($g$), prezzo del gas ($p$), dotazione ($v$) insieme con un insieme di dati di lungherzza arbitraria, $\mathbf{i}$, il codice EVM di inizializzazione ed infine la profondità attuale dello stack del messaggio di chiamata/creazione del contratto ($e$).

Definiamo la funzione di creazione formalmente come la funzione $\Lambda$, che fa una stima da questi valori, insieme con lo stato $\boldsymbol{\sigma}$ verso l'insieme di dati che contiene il nuovo stato, il restante gas e il maturato sottotostato della transazione $(\boldsymbol{\sigma}', g', A)$, come in sezione \ref{ch:transactions}:
\begin{equation}
(\boldsymbol{\sigma}', g', A) \equiv \Lambda(\boldsymbol{\sigma}, s, o, g, p, v, \mathbf{i}, e)
\end{equation}

L'indirizzo del nuovo account è definito come essere più a festra di 160 bits dell'hash di Keccak della codifica RLP della struttura contenete solo il mittente ed il nonce. Perciò definiamo l'indirizzo risultante per il nuovo account $a$:
\begin{equation}
a \equiv \mathcal{B}_{96..255}\Big(\mathtt{\tiny KEC}\Big(\mathtt{\tiny RLP}\big(\;(s, \boldsymbol{\sigma}[s]_n - 1)\;\big)\Big)\Big)
\end{equation}

dove $\mathtt{\tiny KEC}$ è la funzione di hash Keccak 256-bit, $\mathtt{\tiny RLP}$ è la funzione di codifica RLP, $\mathcal{B}_{a..b}(X)$ stima il valore binario contenete i bit degli indici nel range $[a, b]$ dei dati binari $X$ and $\boldsymbol{\sigma}[x]$ è l'indirizzo stato di $x$ or $\varnothing$ se nessuno esiste. Si noti che impieghiamo un valore minore rispetto a quello del nonce del mittente; asseriamo che abbiamo incrementato il nonce dell'account del mittente prima di questa chiamata, e così il valore impiegato nel nonce del mittente all'inizio della transazione che ha dato inizio o dell'operazione VM.

Il nonce dell'account è inizialmente impostato a zero, il saldoThe account's nonce is initially defined as zero, il saldo come il valore passato, lo storage come vuoto e l'hash del codice come hash Keccak 256-bit della stringa vuota; il salndo del mittente è anche ridotto dal valore passato. Quindi lo stato mutato diventa $\boldsymbol{\sigma}^*$:
\begin{equation}
\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except:}
\end{equation}
\begin{eqnarray}
\boldsymbol{\sigma}^*[a] &\equiv& \big( 0, v + v', \mathtt{\tiny TRIE}(\varnothing), \mathtt{\tiny KEC}\big(()\big) \big) \\
\boldsymbol{\sigma}^*[s]_b &\equiv& \boldsymbol{\sigma}^*[s]_b - v
\end{eqnarray}

dove $v'$ è il valore preesistente dell'account, nel caso in cui fosse esistito in precedenza:
\begin{equation}
v' \equiv \begin{cases}
0 & \text{if} \quad \boldsymbol{\sigma}[a] = \varnothing\\
\boldsymbol{\sigma}[a]_b & \text{otherwise}
\end{cases}
\end{equation}

%It is asserted that the state database will also change such that it defines the pair $(\mathtt{\tiny KEC}(\mathbf{b}), \mathbf{b})$.

Infine, l'account è inizializzato attraverso l'esecuzione del codice EVM di inizializzazione $\mathbf{i}$ in accordo al modello di escuzione (si veda la sezione \ref{ch:model}). L'esecuzione del codice può influire diversi eventi che non sono all'interno dello stato di esecuzione: lo storage dell'account può essere alterato, ulteriori account possono essere creati e fatti altri messaggi di chiamata. In quanto tale, la funzione di esecuzione del codice $\Xi$ restituisce un insieme di dati dello stato risultante $\boldsymbol{\sigma}^{**}$, del gas disponibile rimanente $g^{**}$, il sottostato maturato $A$ ed il codice corpo dell'account $\mathbf{b}$.

L'esecuzione del codice esaurisce il gas; quindi esso può uscire prima che il codice è giunto ad uno stato naturale di arresto. In questo (e diversi altri) casi eccezionali possiamo affermare che è avvenuta un eccezzione di Fine-del-gas: Lo stato valutato è definito come un set vuoto $\varnothing$ e l'intera operazione di creazione non dovrebbe avere effetto sullo stato, effettivamente lasciandolo così com'è immediatamente prima di tentare la creazione. Il gas rimanete dovrebbe essere zero in tali eccezionali condizioni. RIVEDI QUA Se la creazione fosse eseguita come la ricezione di una transazione, poi questo non influenzerebbe il pagamento del costo intrinseco: esso è pagato indipendentemente.

Se tale eccezione non si verifica, quindi il gas rimanente è rimborsato al mittente e lo stato ormai alterato può perdurare. Perciò formalmente, possiamo specificare lo stato risultante, gas e sottostato come $(\boldsymbol{\sigma}', g', A)$ dove:

\begin{equation}
(\boldsymbol{\sigma}^{**}, g^{**}, A, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}^*, g, I) \\
\end{equation}
\begin{eqnarray}
\quad g' & \equiv & \begin{cases}
0 & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
g^{**} & \text{if} \quad g^{**} < c \\
g^{**} - c & \text{otherwise} \\
\end{cases} \\
\quad \boldsymbol{\sigma}' & \equiv & \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{if} \quad g^{**} < c \\
\boldsymbol{\sigma}^{**} \quad \text{except:} & \\
\quad\boldsymbol{\sigma}'[a]_c = \texttt{\small KEC}(\mathbf{o}) & \text{otherwise}
\end{cases}
\end{eqnarray}
Dove $I$ contiene i paramentri dell'ambiente di esecuzione come definito nella sezione \ref{ch:model}.
\begin{eqnarray}
I_a & \equiv & a \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_\mathbf{d} & \equiv & () \\
I_s & \equiv & s \\
I_v & \equiv & v \\
I_\mathbf{b} & \equiv & \mathbf{i} \\
I_e & \equiv & e
\end{eqnarray}

dove $c$ è il costo del codice di deposito:
\begin{equation}
c \equiv G_{codedeposit} \times |\mathbf{o}|
\end{equation}

$I_\mathbf{d}$ restituisce l'insieme di dati vuoto in quanto non vi sono dati di input a questa chiamata. $I_H$ non ha uno speciale trattamente ed è determinato dalla blockchain. L'eccezione nella determinazione di $\boldsymbol{\sigma}'$ impone che la sequenza di byte risultante dall'esecuzione del codice di inizializzazione spefica il codice finale del corpo per l'account di nuova creazione, con $\boldsymbol{\sigma}'[a]_c$ che è l'hash Keccak 256-bit del codice corpo dell'account di nuova creazione e $\mathbf{o}$ la sequenza di byte output dell'esecuzione del codice.

Nessun codice è inserito nello stato se il gas non compra la fee di deposito aggiuntiva per byte, comunque, il valore è ancora trasferito e gli effetti collaterali dell'esecuzione hanno corso.

\subsection{Subtleties}
Si noti che mentre il codice di inizializzazione è in esecuzione, l'indirizzio di nuova creazione esiste ma senza nessun codice corpo intrinseco. Quindi qualsiasi messaggio di chiamata ricevuto da esso durante questo periodo comporta che nessun codice venga eseguito. Se l'esecuzione di inizializzazione termina con un istruzione {\small SUICIDE}, la questione è discutibile in quanto l'account sarà eliminato prima che la transazione sia completa. Per un normale {\small STOP} codice, o se il codice restituito è altrimenti vuoto, quindi lo stato è lasciato con un account zombie, e ogni saldo rimanente sarà bloccato nell'account per sempre.

\section{Message Call} \label{ch:call}
Nel caso in cui venga eseguito un messaggio di chiamata, diversi parametri sono richiesti: mittente ($s$), chi esegue per primo la transazione ($o$), destinatario ($r$), l'account il cui codice deve essere eseguito ($c$, di solito lo stesso del ricevente), il gas disponibile ($g$), valore ($v$) ed il prezzo del gas ($p$) insieme con un insieme di dati di lunghezza arbitraria, $\mathbf{d}$, i dati di input della chuamata ed infine l'attuale profondità dello stack messaggio-chiamata/creazione del contratto ($e$).

A prescindere dalla valutazione di un nuovo stato e la transazione sottostato, le chiamate dei messaggi hanno anche un componente extra ---i dati di output data indicati dall'insieme di dati  $\mathbf{o}$. Questo è ingnorato quando si eseguono le transazioni, comunque le chiamate di messaggi possono essere avviate a casusa dell'esecuzione di un codice VM e in questo caso questa informazione è utilizzata.
\begin{equation}
(\boldsymbol{\sigma}', g', A, \mathbf{o}) \equiv \Theta(\boldsymbol{\sigma}, s, o, r, c, g, p, v, \mathbf{d}, e)
\end{equation}

Definiamo $\boldsymbol{\sigma}_1$, il primo stato di transizione come lo stato originario ma con il valore trasferito dal mittente al ricevente:
\begin{equation}
\boldsymbol{\sigma}_1[r]_b \equiv \boldsymbol{\sigma}[r]_b + v \quad\wedge\quad \boldsymbol{\sigma}_1[s]_b \equiv \boldsymbol{\sigma}[s]_b - v
\end{equation}

Attraverso il presente lavoro, si preseume che se $\boldsymbol{\sigma}_1[r]$ fosse in origine indefinito, esso sarà creato come un account con nessun codice o stato e saldo e nonce zero. Quindi la precedente equazione dovrebbe essere interpretata per significare:
\begin{equation}
\boldsymbol{\sigma}_1 \equiv \boldsymbol{\sigma}_1' \quad \text{except:} \\
\end{equation}
\begin{equation}
\boldsymbol{\sigma}_1'[s]_b \equiv \boldsymbol{\sigma}_1[s]_b - v
\end{equation}
\begin{equation}
\text{and}\quad \boldsymbol{\sigma}_1' \equiv \boldsymbol{\sigma} \quad \text{except:} \\
\end{equation}
\begin{equation}
\begin{cases}
\boldsymbol{\sigma}_1'[r] \equiv (v, 0, \mathtt{\tiny KEC}(()), \mathtt{\tiny TRIE}(\varnothing)) & \text{if} \quad \boldsymbol{\sigma}[r] = \varnothing \\
\boldsymbol{\sigma}_1'[r]_b \equiv \boldsymbol{\sigma}[r]_b + v & \text{otherwise}
\end{cases}
\end{equation}

Il codice associanto con l'account (identificato come il frammento il cui hash Keccak è $\boldsymbol{\sigma}[c]_c$) è eseguito in accordo con il modello di esecuzone (si veda la sezione \ref{ch:model}). Proprio come con la creazione del contratto, se l'esecuzione si arresta in modo insolito (ad es. perchè è terminata la riserva di gas, stack underflow, destinazione invalida del salto o un'istruzione invalida), poi nessun gas è rimborsato al chiamante e lo stato torna indietro al punto immediatamente precedente al trassferimento del saldo (ad es. $\boldsymbol{\sigma}$).

\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{otherwise}
\end{cases} \\
(\boldsymbol{\sigma}^{**}, g', \mathbf{s}, \mathbf{o}) & \equiv & \begin{cases}
\Xi_{\mathtt{ECREC}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad a = 1 \\
\Xi_{\mathtt{SHA256}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad a = 2 \\
\Xi_{\mathtt{RIP160}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad a = 3 \\
\Xi_{\mathtt{ID}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad a = 4 \\
\Xi(\boldsymbol{\sigma}_1, g, I) & \text{otherwise} \end{cases} \\
I_a & \equiv & a \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_d & \equiv & d \\
I_\mathbf{d} & \equiv & \mathbf{d} \\
I_s & \equiv & s \\
I_v & \equiv & v \\
I_e & \equiv & e \\
\text{Let} \; \mathtt{\tiny KEC}(I_\mathbf{b}) & = & \boldsymbol{\sigma}[c]_c
\end{eqnarray}

Si presume che il client avrà memorizzato la coppia $(\mathtt{\tiny KEC}(I_\mathbf{b}), I_\mathbf{b})$ in qualche punto prima con il fine di rendere la determinazione $I_\mathbf{b}$ fattibile.

Come si può vedere, ci sono quattro eccezioni all'uso del framework generale di esecuzione $\Xi$ per la valutazione del messaggio di chiamata: queste sono i così detti contratti `precompilati', inteso come un pezzo preliminare di architettura che più in avanti può diventare \textit{native extensions}. I quattro contratti nell'indirizzo 1, 2, 3 e 4 esegueno la funzione di recupero della chiave pubblica a curva ellittica, lo schema hash SHA2 256-bit, lo schema hash RIPEMD 160-bit e rispettivamente la funzione di identità.

La loro piena definizione formale è in \ref{app:precompiled}.

\section{Execution Model} \label{ch:model}

Il modello di esecuzione specifica come lo stato del sistema sia alterato danto una serie di istruzioni bytecode e un piccolo insieme di dati ambientali. Questo è precisato attraverso un modello formale di una macchina di stato virtuale, conosciuto come l' Ethereum Virtual Machine (EVM). Esso è una\textit{quasi-}macchina Turing-complete; la \textit{quasi} qualifica è dovuta dal fatto che la computazione è intrinsicamente delimitata attraverso un parametro, \textit{gas}, che limita l'ammontare complessivo della computazione eseguita.

\subsection{Basics}

The EVM is a simple stack-based architecture. The word size of the machine (and thus size of stack item) is 256-bit. This was chosen to facilitate the Keccak-256 hash scheme and elliptic-curve computations. The memory model is a simple word-addressed byte array. The stack has a maximum size of $1024$. The machine also has an independent storage model; this is similar in concept to the memory but rather than a byte array, it is a word-addressable word array. Unlike memory, which is volatile, storage is non volatile and is maintained as part of the system state. All locations in both storage and memory are well-defined initially as zero.

The machine does not follow the standard von Neumann architecture. Rather than storing program code in generally-accessible memory or storage, it is stored separately in a virtual ROM interactable only through a specialised instruction.

The machine can have exceptional execution for several reasons, including stack underflows and invalid instructions. Like the out-of-gas (OOG) exception, they do not leave state changes intact. Rather, the machine halts immediately and reports the issue to the execution agent (either the transaction processor or, recursively, the spawning execution environment) which will deal with it separately.

\subsection{Fees Overview}

Fees (denominated in gas) are charged under three distinct circumstances, all three as prerequisite to the execution of an operation. The first and most common is the fee intrinsic to the computation of the operation (see Appendix \ref{app:fees}). Secondly, gas may be deducted in order to form the payment for a subordinate message call or contract creation; this forms part of the payment for {\small CREATE}, {\small CALL} and {\small CALLCODE}. Finally, gas may be paid due to an increase in the usage of the memory.

Over an account's execution, the total fee for memory-usage payable is proportional to smallest multiple of 32 bytes that are required such that all memory indices (whether for read or write) are included in the range. This is paid for on a just-in-time basis; as such, referencing an area of memory at least 32 bytes greater than any previously indexed memory will certainly result in an additional memory usage fee. Due to this fee it is highly unlikely addresses will ever go above 32-bit bounds. That said, implementations must be able to manage this eventuality.

Storage fees have a slightly nuanced behaviour---to incentivise minimisation of the use of storage (which corresponds directly to a larger state database on all nodes), the execution fee for an operation that clears an entry in the storage is not only waived, a qualified refund is given; in fact, this refund is effectively paid up-front since the initial usage of a storage location costs substantially more than normal usage.

%More formally, given an instruction, it is possible to calculate the gas cost of executing it as follows:
%
%\begin{itemize}
%\item {\small SHA3} costs $G_{sha3}$ gas
%\item {\small SLOAD} costs $G_{sload}$ gas
%\item {\small BALANCE} costs $G_{balance}$ gas
%\item {\small SSTORE} costs $d.G_{sstore}$ gas where:
%\begin{itemize}
%\item $d = 2$ if the new value of the storage is non-zero and the old is zero;
%\item $d = 0$ if the new value of the storage is zero and the old is non-zero;
%\item $d = 1$ otherwise.
%\end{itemize}
%\item {\small CALL} costs $G_{call}$, though additional gas may be taken for the execution of the account's associated code, if non-empty.
%\item {\small CREATE} costs $G_{create}$, though additional gas may be taken for the execution of the account initialisation code.
%\item {\small STOP} costs $G_{stop}$ gas
%\item {\small SUICIDE} costs $G_{suicide}$ gas
%\item All other operations cost $G_{step}$ gas.
%\end{itemize}
%
%Additionally, when memory is accessed with {\small MSTORE}, {\small MSTORE8}, {\small MLOAD}, {\small CALLDATACOPY}, {\small CODECOPY}, {\small RETURN}, {\small SHA3}, {\small CREATE} or {\small CALL}, the memory should be enlarged to the smallest multiple of words such that all addressed bytes now fit in it.

See Appendix \ref{app:vm} for a rigorous definition of the EVM gas cost.

%Whenever a higher memory index is referenced, the fee difference to take it to the higher usage from the original (lower) usage is charged. Notably, because {\small MSTORE} and {\small MLOAD} operate on word lengths, they implicitly increase the highest-accessed index to 31 greater than their target index.

\subsection{Execution Environment}

In addition to the system state $\boldsymbol{\sigma}$, and the remaining gas for computation $g$, there are several pieces of important information used in the execution environment that the execution agent must provide; these are contained in the tuple $I$:

\begin{itemize}
\item $I_a$, the address of the account which owns the code that is executing.
\item $I_o$, the sender address of the transaction that originated this execution.
\item $I_p$, the price of gas in the transaction that originated this execution.
\item $I_\mathbf{d}$, the byte array that is the input data to this execution; if the execution agent is a transaction, this would be the transaction data.
\item $I_s$, the address of the account which caused the code to be executing; if the execution agent is a transaction, this would be the transaction sender.
\item $I_v$, the value, in Wei, passed to this account as part of the same procedure as execution; if the execution agent is a transaction, this would be the transaction value.
\item $I_\mathbf{b}$, the byte array that is the machine code to be executed.
\item $I_H$, the block header of the present block.
\item $I_e$, the depth of the present message-call or contract-creation (i.e. the number of {\small CALL}s or {\small CREATE}s being executed at present).
\end{itemize}

The execution model defines the function $\Xi$, which can compute the resultant state $\boldsymbol{\sigma}'$, the remaining gas $g'$, the suicide list $\mathbf{s}$, the log series $\mathbf{l}$, the refunds $r$ and the resultant output, $\mathbf{o}$, given these definitions:
\begin{equation}
(\boldsymbol{\sigma}', g', \mathbf{s}, \mathbf{l}, r, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}, g, I)
\end{equation}

\subsection{Execution Overview}

We must now define the $\Xi$ function. In most practical implementations this will be modelled as an iterative progression of the pair comprising the full system state, $\boldsymbol{\sigma}$ and the machine state, $\boldsymbol{\mu}$. Formally, we define it recursively with a function $X$. This uses an iterator function $O$ (which defines the result of a single cycle of the state machine) together with functions $Z$ which determines if the present state is an exceptional halting state of the machine and $H$, specifying the output data of the instruction if and only if the present state is a normal halting state of the machine.

The empty sequence, denoted $()$, is not equal to the empty set, denoted $\varnothing$; this is important when interpreting the output of $H$, which evaluates to $\varnothing$ when execution is to continue but a series (potentially empty) when execution should halt.
\begin{eqnarray}
\Xi(\boldsymbol{\sigma}, g, I) & \equiv & X_{0,1,2,4}\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A^0, I)\big) \\
\boldsymbol{\mu}_g & \equiv & g \\
\boldsymbol{\mu}_{pc} & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{m} & \equiv & (0, 0, ...) \\
\boldsymbol{\mu}_i & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{s} & \equiv & ()
\end{eqnarray}
\begin{equation}
X\big( (\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \big) \equiv \begin{cases}
\big(\varnothing, \boldsymbol{\mu}, A^0, I, ()\big) & \text{if} \quad Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I)\\
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \cdot \mathbf{o} & \text{if} \quad \mathbf{o} \neq \varnothing\\
X\big(O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \text{otherwise}\\
\end{cases}
\end{equation}

where
\begin{eqnarray}
\mathbf{o} & \equiv & H(\boldsymbol{\mu}, I) \\
(a, b, c) \cdot d & \equiv & (a, b, c, d)
\end{eqnarray}

Note that we must drop the fourth value in the tuple returned by $X$ to correctly evaluate $\Xi$, hence the subscript $X_{0,1,2,4}$.

$X$ is thus cycled (recursively here, but implementations are generally expected to use a simple iterative loop) until either $Z$ becomes true indicating that the present state is exceptional and that the machine must be halted and any changes discarded or until $H$ becomes a series (rather than the empty set) indicating that the machine has reached a controlled halt.

\subsubsection{Machine State}
The machine state $\boldsymbol{\mu}$ is defined as the tuple $(g, pc, \mathbf{m}, i, \mathbf{s})$ which are the gas available, the program counter $pc \in \mathbb{P}_{256}$ , the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents $\boldsymbol{\mu}_\mathbf{m}$ are a series of zeroes of size $2^{256}$.

For the ease of reading, the instruction mnemonics, written in small-caps (\eg \space {\small ADD}), should be interpreted as their numeric equivalents; the full table of instructions and their specifics is given in Appendix \ref{app:vm}.

For the purposes of defining $Z$, $H$ and $O$, we define $w$ as the current operation to be executed:
\begin{equation}\label{eq:currentoperation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{if} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert \\
\text{\small STOP} & \text{otherwise}
\end{cases}
\end{equation}

We also assume the fixed amounts of $\mathbf{\delta}$ and $\mathbf{\alpha}$, specifying the stack items removed and added, both subscriptable on the instruction and an instruction cost function $C$ evaluating to the full cost, in gas, of executing the given instruction.

\subsubsection{Exceptional Halting}

The exceptional halting function $Z$ is defined as:
\begin{equation}
Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv
\begin{array}[t]{l}
\boldsymbol{\mu}_g < C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \quad \vee \\
\mathbf{\delta}_w = \varnothing \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert < \mathbf{\delta}_w \quad \vee \\
( w \in \{ \text{\small JUMP}, \text{\small JUMPI} \} \quad \wedge \\ \quad \boldsymbol{\mu}_\mathbf{s}[0] \notin D(I_\mathbf{b}) ) \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert - \mathbf{\delta}_w + \mathbf{\alpha}_w > 1024 \quad
\end{array}
\end{equation}

This states that the execution is in an exceptional halting state if there is insufficient gas, if the instruction is invalid (and therefore its $\delta$ subscript is undefined), if there are insufficient stack items, if a {\small JUMP}/{\small JUMPI} destination is invalid or the new stack size would be larger then 1024. The astute reader will realise that this implies that no instruction can, through its execution, cause an exceptional halt.

\subsubsection{Jump Destination Validity}

We previously used $D$ as the function to determine the set of valid jump destinations given the code that is being run. We define this as any position in the code occupied by a {\small JUMPDEST} instruction.

All such positions must be on valid instruction boundaries, rather than sitting in the data portion of {\small PUSH} operations and must appear within the explicitly defined portion of the code (rather than in the implicitly defined {\small STOP} operations that trail it).

Formally:
\begin{equation}
D(\mathbf{c}) \equiv D_J(\mathbf{c}, 0)
\end{equation}

where:
\begin{equation}
D_J(\mathbf{c}, i) \equiv \begin{cases}
\{\} & \text{if} \quad i \geqslant |\mathbf{c}|  \\
\{ i \} \cup D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{if} \quad \mathbf{c}[i] = \text{\small JUMPDEST} \\
D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{otherwise} \\
\end{cases}
\end{equation}

where $N$ is the next valid instruction position in the code, skipping the data of a {\small PUSH} instruction, if any:
\begin{equation}
N(i, w) \equiv \begin{cases}
i + w - \text{\small PUSH1} + 2 & \text{if} \quad w \in [\text{\small PUSH1}, \text{\small PUSH32}] \\
i + 1 & \text{otherwise} \end{cases}
\end{equation}

\subsubsection{Normal Halting}

The normal halting function $H$ is defined:
\begin{equation}
H(\boldsymbol{\mu}, I) \equiv \begin{cases}
H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) & \text{if} \quad w = \text{\small RETURN} \\
() & \text{if} \quad w \in \{ \text{\small STOP}, \text{\small SUICIDE} \} \\
\varnothing & \text{otherwise}
\end{cases}
\end{equation}

The data-returning halt operation, \text{\small RETURN}, has a special function $H_{\text{\tiny RETURN}}$, defined in Appendix \ref{app:vm}.

\subsection{The Execution Cycle}

Stack items are added or removed from the left-most, lower-indexed portion of the series; all other items remain unchanged:
\begin{eqnarray}
O\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \equiv & (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \\
\Delta & \equiv & \mathbf{\alpha}_w - \mathbf{\delta}_w \\
\lVert\boldsymbol{\mu}'_\mathbf{s}\rVert & \equiv & \lVert\boldsymbol{\mu}_\mathbf{s}\rVert + \Delta \\
\quad \forall x \in [\mathbf{\alpha}_w, \lVert\boldsymbol{\mu}'_\mathbf{s}\rVert): \boldsymbol{\mu}'_\mathbf{s}[x] & \equiv & \boldsymbol{\mu}_\mathbf{s}[x+\Delta]
\end{eqnarray}

The gas is reduced by the instruction's gas cost and for most instructions, the program counter increments on each cycle, for the three exceptions, we assume a function $J$, subscripted by one of two instructions, which evaluates to the according value:
\begin{eqnarray}
\quad \boldsymbol{\mu}'_{g} & \equiv & \boldsymbol{\mu}_{g} - C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \\
\quad \boldsymbol{\mu}'_{pc} & \equiv & \begin{cases}
J_{\text{JUMP}}(\boldsymbol{\mu}) & \text{if} \quad w = \text{\small JUMP} \\
J_{\text{JUMPI}}(\boldsymbol{\mu}) & \text{if} \quad w = \text{\small JUMPI} \\
N(\boldsymbol{\mu}_{pc}, w) & \text{otherwise}
\end{cases}
\end{eqnarray}

In general, we assume the memory, suicide list and system state don't change:
\begin{eqnarray}
\boldsymbol{\mu}'_\mathbf{m} & \equiv & \boldsymbol{\mu}_\mathbf{m} \\
\boldsymbol{\mu}'_i & \equiv & \boldsymbol{\mu}_i \\
A' & \equiv & A \\
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}
\end{eqnarray}

However, instructions do typically alter one or several components of these values. Altered components listed by instruction are noted in Appendix \ref{app:vm}, alongside values for $\alpha$ and $\delta$ and a formal description of the gas requirements.

\section{Blocktree to Blockchain} \label{ch:ghost}

The canonical blockchain is a path from root to leaf through the entire block tree. In order to have consensus over which path it is, conceptually we identify the path that has had the most computation done upon it, or, the \textit{heaviest} path. Clearly one factor that helps determine the heaviest path is the block number of the leaf, equivalent to the number of blocks, not counting the unmined genesis block, in the path. The longer the path, the greater the total mining effort that must have been done in order to arrive at the leaf. This is akin to existing schemes, such as that employed in Bitcoin-derived protocols.

Since a block header includes the difficulty, the header alone is enough to validate the computation done. Any block contributes toward the total computation or \textit{total difficulty} of a chain.

Thus we define the total difficulty of block $B$ recursively as:
\begin{eqnarray}
B_t & \equiv & B'_t + B_d \\
B' & \equiv & P(B_H)
\end{eqnarray}

As such given a block $B$, $B_t$ is its total difficulty, $B'$ is its parent block and $B_d$ is its difficulty.

\section{Block Finalisation} \label{ch:finalisation}

The process of finalising a block involves four stages:

\begin{enumerate}
\item Validate (or, if mining, determine) ommers;
\item validate (or, if mining, determine) transactions;
\item apply rewards;
\item verify (or, if mining, compute a valid) state and nonce.
\end{enumerate}

\subsection{Ommer Validation}

The validation of ommer headers means nothing more than verifying that each ommer header is both a valid header and satisfies the relation of $N$th-generation ommer to the present block where $N \leq 6$. The maximum of ommer headers is two. Formally:
\begin{equation}
\lVert B_\mathbf{U} \rVert \leqslant 2 \bigwedge_{U \in B_\mathbf{U}} V(U) \; \wedge \; k(U, P(B_H), 6)
\end{equation}

where $k$ denotes the ``is-kin'' property:
\begin{equation}
k(U, H, n) \equiv \begin{cases} false & \text{if} \quad n = 0 \\ 
s(U, H) &\\
\quad \vee \; k(U, P(H), n - 1) & \text{otherwise}
\end{cases}
\end{equation}

and $s$ denotes the ``is-sibling'' property:
\begin{equation}
s(U, H) \equiv (P(H) = P(U)\; \wedge \; H \neq U \; \wedge \; U \notin B(H)_\mathbf{U})
\end{equation}
where $B(H)$ is the block of the corresponding header $H$.

\subsection{Transaction Validation}

%where $s[i]$ equals the root of the state trie immediately after the execution of the transaction $B_\mathbf{T}[i]$, and $g[i]$ the total gas used immediately after said transaction.

The given \textbf{gasUsed} must correspond faithfully to the transactions listed: ${B_H}_u$, the total gas used in the block, must be equal to the accumulated gas used according to the final transaction:
\begin{equation}
{B_H}_g = \ell(\mathbf{R})_u
\end{equation}

\subsection{Reward Application}

The application of rewards to a block involves raising the balance of the accounts of the beneficiary address of the block and each ommer by a certain amount. We raise the block's beneficiary account by $R_b$; for each ommer, we raise the block's beneficiary by an additional $\frac{1}{32}$ of the block reward and the beneficiary of the ommer gets rewarded depending on the block number. Formally we define the function $\Omega$:
\begin{eqnarray}
\Omega(B, \boldsymbol{\sigma}) & \equiv & \boldsymbol{\sigma}': \boldsymbol{\sigma}' = \boldsymbol{\sigma} \quad \text{except:} \\
\boldsymbol{\sigma}'[{B_H}_c]_b & = & \boldsymbol{\sigma}[{B_H}_c]_b + (1 + \frac{|B_\mathbf{U}|}{32})R_b \\
\forall_{U \in B_\mathbf{U}}: \\ \nonumber
 \boldsymbol{\sigma}'[U_c]_b & = & \boldsymbol{\sigma}[U_c]_b + (1 + \frac{1}{8} (U_i - {B_H}_i)) R_b 
\end{eqnarray}

If there are collisions of the beneficiary addresses between ommers and the block (i.e. two ommers with the same beneficiary address or an ommer with the same beneficiary address as the present block), additions are applied cumulatively.

We define the block reward as 5 Ether:
\begin{equation}
\text{Let} \quad R_b = 5 \times 10^{18}
\end{equation}

\subsection{State \& Nonce Validation}\label{sec:statenoncevalidation}

We may now define the function, $\Gamma$, that maps a block $B$ to its initiation state:
\begin{equation}
\Gamma(B) \equiv \begin{cases}
\boldsymbol{\sigma}_0 & \text{if} \quad P(B_H) = \varnothing \\
\boldsymbol{\sigma}_i: \mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i)) = {P(B_H)_H}_r & \text{otherwise}
\end{cases}
\end{equation}

Here, $\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i))$ means the hash of the root node of a trie of state $\boldsymbol{\sigma}_i$; it is assumed that implementations will store this in the state database, trivial and efficient since the trie is by nature an immutable data structure.

And finally define $\Phi$, the block transition function, which maps an incomplete block $B$ to a complete block $B'$:
\begin{eqnarray}
\Phi(B) & \equiv & B': \quad B' = B^* \quad \text{except:} \\
B'_n & = & n: \quad x \leqslant \frac{2^{256}}{H_d} \\
B'_m & = & m \quad \text{with } (x, m) = \mathtt{PoW}(B^*_{\hcancel{n}}, n, \mathbf{d}) \\
B^* & \equiv & B \quad \text{except:} \quad B'_r = r(\Pi(\Gamma(B), B))
\end{eqnarray}
With $\mathbf{d}$ being a dataset as specified in appendix \ref{app:ethash}.

As specified at the beginning of the present work, $\Pi$ is the state-transition function, which is defined in terms of $\Omega$, the block finalisation function and $\Upsilon$, the transaction-evaluation function, both now well-defined.

As previously detailed, $\mathbf{R}[n]_{\boldsymbol{\sigma}}$, $\mathbf{R}[n]_\mathbf{l}$ and $\mathbf{R}[n]_u$ are the $n$th corresponding states, logs and cumulative gas used after each transaction ($\mathbf{R}[n]_b$, the fourth component in the tuple, has already been defined in terms of the logs). The former is defined simply as the state resulting from applying the corresponding transaction to the state resulting from the previous transaction (or the block's initial state in the case of the first such transaction):
\begin{equation}
\mathbf{R}[n]_{\boldsymbol{\sigma}} = \begin{cases} \Gamma(B) & \text{if} \quad n < 0 \\ \Upsilon(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n]) & \text{otherwise} \end{cases}
\end{equation}

In the case of $B_\mathbf{R}[n]_u$, we take a similar approach defining each item as the gas used in evaluating the corresponding transaction summed with the previous item (or zero, if it is the first), giving us a running total:
\begin{equation}
\mathbf{R}[n]_u = \begin{cases} 0 & \text{if} \quad n < 0 \\
\begin{array}[b]{l}
\Upsilon^g(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])\\ \quad + \mathbf{R}[n-1]_u
\end{array}
 & \text{otherwise} \end{cases}
\end{equation}

For $\mathbf{R}[n]_\mathbf{l}$, we utilise the $\Upsilon^\mathbf{l}$ function that we conveniently defined in the transaction execution function.
\begin{equation}
\mathbf{R}[n]_\mathbf{l} = 
\Upsilon^\mathbf{l}(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])
\end{equation}

Finally, we define $\Pi$ as the new state given the block reward function $\Omega$ applied to the final transaction's resultant state, $\ell(B_\mathbf{R})_{\boldsymbol{\sigma}}$:
\begin{equation}
\Pi(\boldsymbol{\sigma}, B) \equiv \Omega(B, \ell(\mathbf{R})_{\boldsymbol{\sigma}})
\end{equation}

Thus the complete block-transition mechanism, less $\mathtt{PoW}$, the proof-of-work function is defined.

\subsection{Mining Proof-of-Work} \label{ch:pow}

Il mining proof-of-work (PoW) esiste come un nonce crittograficamente sicuro al di là di ogni ragionevole dubbio che una particolare quantità di computazione è stata spesa per determinare il valore di un token $n$. Il PoW è utilizzato per imporre la sicurezza della blockchain dando senso e credibilità alla nozione di difficoltà (e, per estensione, alla difficoltà totale). Tuttavia, visto che il mining di nuovi blocchi ha anche una ricompensa annessa, il proof-of-work non solo funge come un metodo per garantire la fiducia che una blockchain rimanga canonica nel futuro, ma funge anche da meccanismo di distribuzione della ricchezza.

Per entrambe le [succitate?] ragioni, ci sono due importanti obiettivi della funzione proof-of-work; in primo luogo, dovrebbe essere il più accessibile possibile[rima] a quante più persone possibile. Il requisito di, o la ricompensa data da, hardware poco comune o specializzato dovrebbe essere ridotto al minimo. Questo rende il modello di distribuzione[distributivo?] il più aperto possibile, e, idealmente, rende il mining un semplice scambio da elettricità ad Ether approssimativamente allo stesso prezzo per chiunque in tutto il mondo.

In secondo luogo, non dovrebbe essere possibile avere profitti superlineari, e in particolar modo, non con una barriera iniziale così elevata. Tale meccanismo permette ad un avversario ben finanziato di ottenere una preoccupante[interpretazione di troublesome] quantità della potenza di mining totale e come tale gli dà una ricompensa superlineare (quindi facendo pendere la distribuzione in loro favore) riducendo anche la sicurezza della rete.

Un problema del mondo di Bitcoin sono gli ASIC. Questi sono dei componenti hardware specializzati che esistono solo per assolvere un singolo compito. Nel caso di Bitcoin il compito è la funzione di hash SHA 256. Finchè gli ASIC esisteranno per la funzione di proof-of-work, entrambi gli obiettivi saranno in pericolo. A causa di ciò, una funzione proof-of-work che è resistente agli ASIC (cioè difficile o economicamente inefficiente da implementare in hardware specializzato) è stato identificato come la proverbiale pallottola d'argento.

Esistono due strade per raggiungere la resistenza agli ASIC; in primo luogo rendere sequenziale l'utilizzo della memoria, cioè ingegnerizzare la funzione in modo che la determinazione del nonce richiede molta memoria e banda passante in modo che la memoria non possa essere usata in parallelo per trovare molteplici nonce contemporaneamente. Il secondo è quello di rendere generico il tipo di calcolo che dovrebbe fare; il significato di ``hardware specializzato'' per un compito generico è ,naturalmente, hardware per uso generico e come tale i desktop computer sono i candidati più probabili per essere ``hardware specialiazzato'' per il compito. Per Ethereum 1.0 scelto la prima strada.

Formalmente parlando, la funzione proof-of-work prende la forma di $\mathtt{PoW}$:
\begin{equation}
m = H_m \quad \wedge \quad n \leqslant \frac{2^{256}}{H_d} \quad \text{with} \quad (m, n) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})
\end{equation}

Dove $H_{\hcancel{n}}$ è la nuova intestazione del blocco \textit{senza} il nonce e i componenti di mix-hash; $H_n$ è il nonce dell'intestazione; $\mathbf{d}$ è un grande insieme di dati necessari a computare il mix-hash e $H_d$ è il valore della difficoltà del nuovo blocco (cioè la difficoltà del blocco dalla sezione \ref{ch:ghost}). $\mathtt{PoW}$ è la funzione proof-of-work che restituisce  una struttura dati il cui primo elemento è il mix-hash ed il secondo elemento è un numero pseudo-casuale crittograficamente dipendente da $H$ e $\mathbf{d}$. L'algoritmo alla base è chiamato Ethashed è descritto di seguito.
\subsubsection{Ethash}
Ethash è l'algoritmo PoW previsto per Ethereum 1.0. E' l'ultima versione di Dagger-Hashimoto, introdotta da \cite{dagger} e \cite{hashimoto}, sebbene non possa più essere chiamato come tale dal momento che molte delle caratteristiche originali di entrambi gli algoritmi sono state drasticamente cambiate nell'ultimo mese di ricerca e sviluppo. Il tracciato generale che l'algoritmo prende è il seguente:

Per ogni blocco esiste un seed che può essere computato analizzando le intestazioni dei blocchi fino al momento della computazione. Dal seed, si può calcolare una cache pseudocasuale, $J_{cacheinit}$ bytes di dimensione iniziale. I light clients immagazzinano la cache. Dalla cache, si può generare un set di dati, $J_{datasetinit}$ bytes di dimensione iniziale, con la caratteristica che ciascun elemento del set di dati dipende soltanto un numero limitato di elementi dalla cache. Full clients e miners immagazzinano il set di dati. Il set di dati cresce in modo lineare col passare del tempo.

Il mining comporta la selezione casuale di parti del set di dati per mescolarle insieme. La verifica può essere effettuata con poca memoria usando la cache per rigenerare le parti necessarie del set di dati, in tal modo solo la memorizzazione si limita alla cache. Il set di dati completo è aggiornato una volta ogni $J_{epoch}$ blocchi, cosicchè la grande maggioranza del lavoro di un miner sarà la lettura del set di dati e non l'apporto di modifiche ad esso. I parametri succitati così come l'algoritmo usato sono spiegati in dettaglio nell'appendice \ref{app:ethash}.

\section{Implementing Contracts}

Ci sono diversi tipi di ingegnerizzazione dei contratti che consentono applicazioni il cui funzionamento è di particolare utilità; due di questi sono i feed dati e i numeri casuali. 

\subsection{Data Feeds}
A data feed contract is one which provides a single service: it gives access to information from the external world within Ethereum. The accuracy and timeliness of this information is not guaranteed and it is the task of a secondary contract author---the contract that utilises the data feed---to determine how much trust can be placed in any single data feed.

The general pattern involves a single contract within Ethereum which, when given a message call, replies with some timely information concerning an external phenomenon. An example might be the local temperature of New York City. This would be implemented as a contract that returned that value of some known point in storage. Of course this point in storage must be maintained with the correct such temperature, and thus the second part of the pattern would be for an external server to run an Ethereum node, and immediately on discovery of a new block, creates a new valid transaction, sent to the contract, updating said value in storage. The contract's code would accept such updates only from the identity contained on said server.

\subsection{Random Numbers}
Providing random numbers within a deterministic system is, naturally, an impossible task. However, we can approximate with pseudo-random numbers by utilising data which is generally unknowable at the time of transacting. Such data might include the block's hash, the block's timestamp and the block's beneficiary address. In order to make it hard for malicious miner to control those values, one should use the {\small BLOCKHASH} operation in order to use hashes of the previous 256 blocks as pseudo-random numbers. For a series of such numbers, a trivial solution would be to add some constant amount and hashing the result.

\section{Future Directions} \label{ch:future}

The state database won't be forced to maintain all past state trie structures into the future. It should maintain an age for each node and eventually discard nodes that are neither recent enough nor checkpoints; checkpoints, or a set of nodes in the database that allow a particular block's state trie to be traversed, could be used to place a maximum limit on the amount of computation needed in order to retrieve any state throughout the blockchain.

Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download to act as a full, mining, node. A compressed archive of the trie structure at given points in time (perhaps one in every 10000th block) could be maintained by the peer network, effectively recasting the genesis block. This would reduce the amount to be downloaded to a single archive plus a hard maximum limit  of blocks.

Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven't sent/received a transaction in some constant amount of blocks could be thrown out, reducing both Ether-leakage and the growth of the state database.

\subsection{Scalability}

Scalability remains an eternal concern. With a generalised state transition function, it becomes difficult to partition and parallelise transactions to apply the divide-and-conquer strategy. Unaddressed, the dynamic value-range of the system remains essentially fixed and as the average transaction value increases, the less valuable of them become ignored, being economically pointless to include in the main ledger. However, several strategies exist that may potentially be exploited to provide a considerably more scalable protocol.

Some form of hierarchical structure, achieved by either consolidating smaller lighter-weight chains into the main block or building the main block through the incremental combination and adhesion (through proof-of-work) of smaller transaction sets may allow parallelisation of transaction combination and block-building. Parallelism could also come from a prioritised set of parallel blockchains, consolidated each block and with duplicate or invalid transactions thrown out accordingly.

Finally, verifiable computation, if made generally available and efficient enough, may provide a route to allow the proof-of-work to be the verification of final state.

\section{Conclusion} \label{ch:conclusion}

I have introduced, discussed and formally defined the protocol of Ethereum. Through this protocol the reader may implement a node on the Ethereum network and join others in a decentralised secure social operating system. Contracts may be authored in order to algorithmically specify and autonomously enforce rules of interaction.

\section{Acknowledgements}

Important maintenance, useful corrections and suggestions were provided by a number of others from the Ethereum DEV organisation and Ethereum community at large including Christoph Jentzsch, Gustav Simonsson, Aeron Buchanan, Pawe\l{} Bylica, Jutta Steiner, Nick Savers, Viktor Tr\'{o}n, Marko Simovic and, of course, Vitalik Buterin.

\bibliography{Biblio}
\bibliographystyle{plainnat}

\end{multicols}

\appendix

\section{Terminology}

\begin{description}
\item[External Actor] A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.

\item[Address] A 160-bit code used for identifying Accounts.

\item[Account] Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.

\item[Transaction] A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.

\item[Autonomous Object] A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated only as the Storage State of that account.

\item[Storage State] The information particular to a given Account that is maintained between the times that the Account's associated EVM Code runs.

\item[Message] Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.

\item[Message Call] The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.

\item[Gas] The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.

\item[Contract] Informal term used to mean both a piece of EVM Code that may be associated with an Account or an Autonomous Object.

\item[Object] Synonym for Autonomous Object.

\item[App] An end-user-visible application hosted in the Ethereum Browser.

\item[Ethereum Browser] (aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum protocol.

\item[Ethereum Virtual Machine] (aka EVM) The virtual machine that forms the key part of the execution model for an Account's associated EVM Code.

\item[Ethereum Runtime Environment] (aka ERE) The environment which is provided to an Autonomous Object executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for certain I/O instructions including CALL \& CREATE.

\item[EVM Code] The bytecode that the EVM can natively execute. Used to formally specify the meaning and ramifications of a message to an Account.

\item[EVM Assembly] The human-readable form of EVM-code.

\item[LLL] The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general low-level language toolkit for trans-compiling to.

\end{description}

\section{Recursive Length Prefix}\label{app:rlp}
This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).

We define the set of possible structures $\mathbb{T}$:
\begin{eqnarray}
\mathbb{T} & \equiv & \mathbb{L} \cup \mathbb{B} \\
\mathbb{L} & \equiv & \{ \mathbf{t}: \mathbf{t} = ( \mathbf{t}[0], \mathbf{t}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{t} \rVert} \; \mathbf{t}[n] \in \mathbb{T} \} \\
\mathbb{B} & \equiv & \{ \mathbf{b}: \mathbf{b} = ( \mathbf{b}[0], \mathbf{b}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{b} \rVert} \; \mathbf{b}[n] \in \mathbb{Y} \}
\end{eqnarray}

Where $\mathbb{Y}$ is the set of bytes. Thus $\mathbb{B}$ is the set of all sequences of bytes (otherwise known as byte-arrays, and a leaf if imagined as a tree), $\mathbb{L}$ is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined as a tree) and $\mathbb{T}$ is the set of all byte-arrays and such structural sequences.

We define the RLP function as $\mathtt{\tiny RLP}$ through two sub-functions, the first handling the instance when the value is a byte array, the second when it is a sequence of further values:
\begin{equation}
\mathtt{\tiny RLP}(\mathbf{x}) \equiv \begin{cases} R_b(\mathbf{x}) & \text{if} \quad \mathbf{x} \in \mathbb{B} \\ R_l(\mathbf{x}) & \text{otherwise} \end{cases}
\end{equation}

If the value to be serialised is a byte-array, the RLP serialisation takes one of three forms:

\begin{itemize}
\item If the byte-array contains solely a single byte and that single byte is less than 128, then the input is exactly equal to the output.
\item If the byte-array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to the length of the byte array plus 128.
\item Otherwise, the output is equal to the input prefixed by the minimal-length byte-array which when interpreted as a big-endian integer is equal to the length of the input byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 183.
\end{itemize}

Formally, we define $R_b$:
\begin{eqnarray}
R_b(\mathbf{x}) & \equiv & \begin{cases}
\mathbf{x} & \text{if} \quad \lVert \mathbf{x} \rVert = 1 \wedge \mathbf{x}[0] < 128 \\
(128 + \lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{else if} \quad \lVert \mathbf{x} \rVert < 56 \\
\big(183 + \big\lVert \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{otherwise}
\end{cases} \\
\mathtt{\tiny BE}(x) & \equiv & (b_0, b_1, ...): b_0 \neq 0 \wedge \sum_{n = 0}^{n < \lVert \mathbf{b} \rVert - 1} b_n \cdot 256^{\lVert \mathbf{b} \rVert - 1 - n} \\
(a) \cdot (b, c) \cdot (d, e) & = & (a, b, c, d, e)
\end{eqnarray}

Thus $\mathtt{\tiny BE}$ is the function that expands a positive integer value to a big-endian byte array of minimal length and the dot operator performs sequence concatenation.

If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:

\begin{itemize}
\item If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal to that concatenation prefixed by the byte equal to the length of this byte array plus 192.
\item Otherwise, the output is equal to the concatenated serialisations prefixed by the minimal-length byte-array which when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 247.
\end{itemize}

Thus we finish by formally defining $R_l$:
\begin{eqnarray}
R_l(\mathbf{x}) & \equiv & \begin{cases}
(192 + \lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{if} \quad \lVert s(\mathbf{x}) \rVert < 56 \\
\big(247 + \big\lVert \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{otherwise}
\end{cases} \\
s(\mathbf{x}) & \equiv & \mathtt{\tiny RLP}(\mathbf{x}_0) \cdot \mathtt{\tiny RLP}(\mathbf{x}_1) ...
\end{eqnarray}

If RLP is used to encode a scalar, defined only as a positive integer ($\mathbb{P}$ or any $x$ for $\mathbb{P}_x$), it must be specified as the shortest byte array such that the big-endian interpretation of it is equal. Thus the RLP of some positive integer $i$ is defined as:
\begin{equation}
\mathtt{\tiny RLP}(i : i \in \mathbb{P}) \equiv \mathtt{\tiny RLP}(\mathtt{\tiny BE}(i))
\end{equation}

When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data, dismissing it completely.

There is no specific canonical encoding format for signed or floating-point values.

\section{Hex-Prefix Encoding}\label{app:hexprefix}
Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates between node types.

It is defined as the function $\mathtt{\tiny HP}$ which maps from a sequence of nibbles (represented by the set $\mathbb{Y}$) together with a boolean value to a sequence of bytes (represented by the set $\mathbb{B}$):

\begin{eqnarray}
\mathtt{\tiny HP}(\mathbf{x}, t): \mathbf{x} \in \mathbb{Y} & \equiv & \begin{cases}
(16f(t), 16\mathbf{x}[0] + \mathbf{x}[1], 16\mathbf{x}[2] + \mathbf{x}[3], ...) &
\text{if} \quad \lVert \mathbf{x} \rVert \; \text{is even} \\
(16(f(t) + 1) + \mathbf{x}[0], 16\mathbf{x}[1] + \mathbf{x}[2], 16\mathbf{x}[3] + \mathbf{x}[4], ...) &
\text{otherwise}
\end{cases} \\
f(t) & \equiv & \begin{cases} 2 & \text{if} \quad t \neq 0 \\ 0 & \text{otherwise} \end{cases}
\end{eqnarray}

Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the second-lowest encoding the flag $t$. The low nibble of the first byte is zero in the case of an even number of nibbles and the first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining bytes.

\section{Modified Merkle Patricia Tree}\label{app:trie}
The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms of the protocol specification is to provide a single value that identifies a given set of key-value pairs, which may either a 32 byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the structure of the trie in a manner the allows effective and efficient realisation of the protocol.

Formally, we assume the input value $\mathfrak{I}$, a set containing pairs of byte sequences:
\begin{equation}
\mathfrak{I} = \{ (\mathbf{k}_0 \in \mathbb{B}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1 \in \mathbb{B}, \mathbf{v}_1 \in \mathbb{B}), ... \}
\end{equation}

When considering such a sequence, we use the common numeric subscript notation to refer to a tuple's key or value, thus:
\begin{equation}
\forall_{I \in \mathfrak{I}} I \equiv (I_0, I_1)
\end{equation}

Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume big-endian. Thus:
\begin{eqnarray}
y(\mathfrak{I}) & = & \{ (\mathbf{k}_0' \in \mathbb{Y}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1' \in \mathbb{Y}, \mathbf{v}_1 \in \mathbb{B}), ... \} \\
\forall_n \quad \forall_{i: i < 2\lVert\mathbf{k}_n\rVert} \quad \mathbf{k}_n'[i] & \equiv &
\begin{cases}
\lfloor \mathbf{k}_n[i \div 2] \div 16 \rfloor & \text{if} \; i \; \text{is even} \\
\mathbf{k}_n[\lfloor i \div 2 \rfloor] \bmod 16 & \text{otherwise}
\end{cases}
\end{eqnarray}

We define the function $\texttt{\small TRIE}$, which evaluates to the root of the trie that represents this set when encoded in this structure:
\begin{equation}
\texttt{\small TRIE}(\mathfrak{I}) \equiv \texttt{\small KEC}(c(\mathfrak{I}, 0))
\end{equation}

We also assume a function $n$, the trie's node cap function. When composing a node, we use RLP to encode the structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference. Thus we define in terms of $c$, the node composition function:
\begin{equation}
n(\mathfrak{I}, i) \equiv \begin{cases}
() & \text{if} \quad \mathfrak{I} = \varnothing \\
c(\mathfrak{I}, i) & \text{if} \quad \lVert c(\mathfrak{I}, i)\rVert < 32 \\
\texttt{\small KEC}(c(\mathfrak{I}, i)) & \text{otherwise}
\end{cases}
\end{equation}

In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree). Unlike a radix tree, in the case of multiple keys shared the same prefix or in the case of a single key having a unique suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
\begin{description}
\item[Leaf] A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $true$.
\item[Extension] A two-item structure whose first item corresponds to a series of nibbles of size greater than one that are shared by at least two distinct keys past the accumulation of nibbles keys and branches as traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $false$.
\item[Branch] A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and thus a key being ended at this point in its traversal.
\end{description}

A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We may formally define this structure with the structural composition function $c$:
\begin{equation}
c(\mathfrak{I}, i) \equiv \begin{cases}
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (\lVert I_0\rVert - 1)], true), I_1 \big) \Big) & \text{if} \quad \lVert \mathfrak{I} \rVert = 1 \quad \text{where} \; \exists I: I \in \mathfrak{I} \\
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (j - 1)], false), n(\mathfrak{I}, j) \big) \Big) & \text{if} \quad i \ne j \quad \text{where} \; j = \arg \max_x : \exists \mathbf{l}: \lVert \mathbf{l} \rVert = x : \forall_{I \in \mathfrak{I}}: I_0[0 .. (x - 1)] = \mathbf{l} \\
\texttt{\small RLP}\Big( (u(0), u(1), ..., u(15), v) \Big) & \text{otherwise} \quad \text{where} \begin{array}[t]{rcl}
u(j) & \equiv & n(\{ I : I \in \mathfrak{I} \wedge I_0[i] = j \}, i + 1) \\
v & = & \begin{cases}
I_1 & \text{if} \quad \exists I: I \in \mathfrak{I} \wedge \lVert I_0 \rVert = i \\
() & \text{otherwise}
\end{cases}
\end{array}
\end{cases}
\end{equation}

\subsection{Trie Database}
Thus no explicit assumptions are made concerning what data is stored and what is not, since that is an implementation-specific consideration; we simply define the identity function mapping the key-value set $\mathfrak{I}$ to a 32-byte hash and assert that only a single such hash exists for any $\mathfrak{I}$, which though not strictly true is accurate within acceptable precision given the Keccak hash's collision resistance. In reality, a sensible implementation will not fully recompute the trie root hash for each set.

A reasonable implementation will maintain a database of nodes determined from the computation of various tries or, more formally, it will memoise the function $c$. This strategy uses the nature of the trie to both easily recall the contents of any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship, Merkle-proofs may be constructed with an $O(\log N)$ space requirement that can demonstrate a particular leaf must exist within a trie of a given root hash.

\section{Precompiled Contracts}\label{app:precompiled}

For each precompiled contract, we make use of a template function, $\Xi_{\mathtt{PRE}}$, which implements the out-of-gas checking.
\begin{equation}
\Xi_{\mathtt{PRE}}(\boldsymbol{\sigma}, g, I) \equiv \begin{cases}
(\varnothing, 0, A^0, ()) & \text{if} \quad g < g_r \\
(\boldsymbol\sigma, g - g_r, A^0, \mathbf{o}) & \text{otherwise}\end{cases}
\end{equation}

The precompiled contracts each use these definitions and provide specifications for the $\mathbf{o}$ (the output data) and $g_r$, the gas requirements.

For the elliptic curve DSA recover VM execution function, we also define $\mathbf{d}$ to be the input data, well-defined for an infinite length by appending zeroes as required. Importantly in the case of an invalid signature ($\mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing$), then we have no output.
\begin{eqnarray}
\Xi_{\mathtt{ECREC}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 3000\\
|\mathbf{o}| &=& \begin{cases} 0 & \text{if} \quad \mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing\\ 32 & \text{otherwise} \end{cases}\\
\text{if} \quad |\mathbf{o}| = 32: &&\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny KEC}\big(\mathtt{\tiny ECDSARECOVER}(h, v, r, s)\big)[12..31] \quad \text{where:}\\
\mathbf{d}[0..(|I_\mathbf{d}|-1)] &=& I_\mathbf{d}\\
\mathbf{d}[|I_\mathbf{d}|..] &=& (0, 0, ...) \\
h &=& \mathbf{d}[0..31]\\
v &=& \mathbf{d}[32..63]\\
r &=& \mathbf{d}[64..95]\\
s &=& \mathbf{d}[96..127]
\end{eqnarray}

The two hash functions, RIPEMD-160 and SHA2-256 are more trivially defined as an almost pass-through operation. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.
\begin{eqnarray}
\Xi_{\mathtt{SHA256}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 60 + 12\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..31] &=& \mathtt{\tiny SHA256}(I_\mathbf{d})\\
\Xi_{\mathtt{RIP160}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 600 + 120\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny RIPEMD160}(I_\mathbf{d})\\
\end{eqnarray}

For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and SHA2-256 of the form:
\begin{eqnarray}
\mathtt{\small SHA256}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{32} \\
\mathtt{\small RIPEMD160}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{20}
\end{eqnarray}

Finally, the fourth contract, the identity function $\Xi_{\mathtt{ID}}$ simply defines the output as the input:
\begin{eqnarray}
\Xi_{\mathtt{ID}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 15 + 3\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o} &=& I_\mathbf{d}
\end{eqnarray}


\section{Signing Transactions}\label{app:signing}

The method of signing transactions is similar to the `Electrum style signatures'; it utilises the SECP-256k1 curve as described by \cite{gura2004comparing}.

It is assumed that the sender has a valid private key $p_r$, a randomly selected positive integer
% to avoid line break in range definition

in the range $(1, \mathtt{\tiny secp256k1n} - 1)$ represented as a byte array of length 32 in big-endian form.

We assert the functions $\mathtt{\small ECDSASIGN}$, $\mathtt{\small ECDSARESTORE}$ and $\mathtt{\small ECDSAPUBKEY}$. These are formally defined in the literature.
\begin{eqnarray}
\mathtt{\small ECDSAPUBKEY}(p_r \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64} \\
\mathtt{\small ECDSASIGN}(e \in \mathbb{B}_{32}, p_r \in \mathbb{B}_{32}) & \equiv & (v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) \\
\mathtt{\small ECDSARECOVER}(e \in \mathbb{B}_{32}, v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64}
\end{eqnarray}

Where $p_u$ is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive integers each $< 2^{256}$) and $p_r$ is the private key, a byte array of size 32 (or a single positive integer in the aforementioned range). It is assumed that $v$ is the `recovery id', a 1 byte value specifying the sign and finiteness of the curve point; this value is in the range of $[27, 30]$, however we declare the upper two possibilities, representing infinite values, invalid.

We declare that a signature is invalid unless the following is true:
\begin{eqnarray}
0 < r < \mathtt{\tiny secp256k1n} \quad\wedge\quad \\
0 < s < \mathtt{\tiny secp256k1n} \quad\wedge\quad \\
v \in \{27,28\}
\end{eqnarray}

where:
\begin{eqnarray}
\mathtt{\tiny secp256k1n} &=& 115792089237316195423570985008687907852837564279074904382605163141518161494337
%\mathtt{\tiny secp256k1p} &=& 2^{256} - 2^{32} - 977\\
\end{eqnarray}

For a given private key, $p_r$, the Ethereum address $A(p_r)$ (a 160-bit value) to which it corresponds is defined as the right most 160-bits of the Keccak hash of the corresponding ECDSA public key:
\begin{equation}
A(p_r) = \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSAPUBKEY}(p_r) \big) \big)
\end{equation}

The message hash, $h(T)$, to be signed is the Keccak hash of the transaction without the latter three signature components, formally described as $T_r$, $T_s$ and $T_w$:
\begin{eqnarray}
L_S(T) & \equiv & \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}) & \text{if} \; T_t = 0\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}) & \text{otherwise} 
\end{cases} \\
h(T) & \equiv & \mathtt{\small KEC}( L_S(T) )
\end{eqnarray}

The signed transaction $G(T, p_r)$ is defined as:
\begin{eqnarray}
G(T, p_r) \equiv T \quad \text{except:} \\
(T_w, T_r, T_s) = \mathtt{\small ECDSASIGN}(h(T), p_r)
\end{eqnarray}

We may then define the sender function $S$ of the transaction as:
\begin{equation}
S(T) \equiv \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSARECOVER}(h(T), T_w, T_r, T_s) \big) \big)
\end{equation}

The assertion that the sender of the a signed transaction equals the address of the signer should be self-evident:
\begin{equation}
\forall T: \forall p_r: S(G(T, p_r)) \equiv A(p_r)
\end{equation}

\section{Fee Schedule}\label{app:fees}

The fee schedule $G$ is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description* \\
\midrule
$G_{zero}$ & 0 & Nothing paid for operations of the set {\small $W_{zero}$}. \\
$G_{base}$ & 2 & Amount of gas to pay for operations of the set {\small $W_{base}$}. \\
$G_{verylow}$ & 3 & Amount of gas to pay for operations of the set {\small $W_{verylow}$}. \\
$G_{low}$ & 5 & Amount of gas to pay for operations of the set {\small $W_{low}$}. \\
$G_{mid}$ & 8 & Amount of gas to pay for operations of the set {\small $W_{mid}$}. \\
$G_{high}$ & 10 & Amount of gas to pay for operations of the set {\small $W_{high}$}. \\
$G_{ext}$ & 20 & Amount of gas to pay for operations of the set {\small $W_{ext}$}. \\
$G_{sload}$ & 50 & Paid for a {\small SLOAD} operation. \\
$G_{jumpdest}$ & 1 & Paid for a {\small JUMPDEST} operation. \\
$G_{sset}$ & 20000 & Paid for an {\small SSTORE} operation when the storage value is set to non-zero from zero. \\
$G_{sreset}$ & 5000 & Paid for an {\small SSTORE} operation when the storage value's zeroness remains unchanged or is set to zero. \\
$R_{sclear}$ & 15000 & Refund given (added into refund counter) when the storage value is set to zero from non-zero. \\
$R_{suicide}$ & 24000 & Refund given (added into refund counter) for suiciding an account. \\
$G_{create}$ & 32000 & Paid for a {\small CREATE} operation. \\
$G_{codedeposit}$ & 200 & Paid per byte for a {\small CREATE} operation to succeed in placing code into state. \\
$G_{call}$ & 40 & Paid for a {\small CALL} operation. \\
$G_{callvalue}$ & 9000 & Paid for a non-zero value transfer as part of the {\small CALL} operation. \\
$G_{callstipend}$ & 2300 & A stipend for the called contract subtracted from $G_{callvalue}$ for a non-zero value transfer. \\
$G_{callnewaccount}$ & 25000 & Paid for a {\small CALL} operation to a not previously excisting account. \\
$G_{exp}$ & 10 & Partial payment for an {\small EXP} operation. \\
$G_{expbyte}$ & 10 & Partial payment when multiplied by $\lceil\log_{256}(exponent)\rceil$ for the {\small EXP} operation. \\
$G_{memory}$ & 3 & Paid for every additional word when expanding memory. \\
$G_{txdatazero}$ & 4 & Paid for every zero byte of data or code for a transaction. \\
$G_{txdatanonzero}$ & 68 & Paid for every non-zero byte of data or code for a transaction. \\
$G_{transaction}$ & 21000 & Paid for every transaction. \\
$G_{log}$ & 375 & Partial payment for a {\small LOG} operation. \\
$G_{logdata}$ & 8 & Paid for each byte in a {\small LOG} operation's data. \\
$G_{logtopic}$ & 375 & Paid for each topic of a {\small LOG} operation. \\
$G_{sha3}$ & 30 & Paid for each {\small SHA3} operation. \\
$G_{sha3word}$ & 6 & Paid for each word (rounded up) for input data to a {\small SHA3} operation. \\
$G_{copy}$ & 3 & Partial payment for {\small *COPY} operations, multiplied by words copied, rounded up. \\

%extern u256 const c_copyGas;			///< Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.
\bottomrule
\end{tabular*}

\section{Virtual Machine Specification}\label{app:vm}

When interpreting 256-bit binary values as integers, the representation is big-endian.

When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE) 20 bytes are used and the left most 12 are discarded or filled with zeroes, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.

\subsection{Gas Cost}

The general gas cost function, $C$, is defined as:

\begin{equation}
C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv C_{memory}(\boldsymbol{\mu}'_i)-C_{memory}(\boldsymbol{\mu}_i) + \begin{cases}
C_\text{\tiny SSTORE}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small SSTORE} \\
G_{exp} & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] = 0 \\
G_{exp} + G_{expbyte}\times(1+\lfloor\log_{256}(\boldsymbol{\mu}_\mathbf{s}[1])\rfloor) & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] > 0 \\
G_{verylow} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[2] \div 32\rceil & \text{if} \quad w = \text{\small CALLDATACOPY} \lor \text{\small CODECOPY} \\
G_{ext} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[3] \div 32\rceil & \text{if} \quad w = \text{\small EXTCODECOPY} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1] & \text{if} \quad w = \text{\small LOG0} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+G_{logtopic} & \text{if} \quad w = \text{\small LOG1} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+2G_{logtopic} & \text{if} \quad w = \text{\small LOG2} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+3G_{logtopic} & \text{if} \quad w = \text{\small LOG3} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+4G_{logtopic} & \text{if} \quad w = \text{\small LOG4} \\
C_\text{\tiny CALL}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small CALL} \lor \text{\small CALLCODE} \\
G_{create} & \text{if} \quad w = \text{\small CREATE}\\
G_{sha3}+G_{sha3word} \lceil \mathbf{s}[1] \div 32 \rceil & \text{if} \quad w = \text{\small SHA3}\\
G_{jumpdest} & \text{if} \quad w = \text{\small JUMPDEST}\\
G_{sload} & \text{if} \quad w = \text{\small SLOAD}\\
G_{zero} & \text{if} \quad w \in W_{zero}\\
G_{base} & \text{if} \quad w \in W_{base}\\
G_{verylow} & \text{if} \quad w \in W_{verylow}\\
G_{low} & \text{if} \quad w \in W_{low}\\
G_{mid} & \text{if} \quad w \in W_{mid}\\
G_{high} & \text{if} \quad w \in W_{high}\\
G_{ext} & \text{if} \quad w \in W_{ext}
\end{cases}
\end{equation}
\begin{equation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{if} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert\\
\text{\small STOP} & \text{otherwise}
\end{cases}
\end{equation}

where:
\begin{equation}
C_{memory}(a) \equiv G_{memory} \cdot a + \Big\lfloor \dfrac{a^2}{512} \Big\rfloor
\end{equation}

with $C_\text{\tiny CALL}$ and $C_\text{\tiny SSTORE}$ as specified in the appropriate section below. We define the following subsets of instructions:

$W_{zero}$ = \{{\small STOP}, {\small SUICIDE}, {\small RETURN}\}

$W_{base}$ = \{{\small ADDRESS}, {\small ORIGIN}, {\small CALLER}, {\small CALLVALUE}, {\small CALLDATASIZE}, {\small CODESIZE}, {\small GASPRICE}, {\small COINBASE},\newline \noindent\hspace*{1cm} {\small TIMESTAMP}, {\small NUMBER}, {\small DIFFICULTY}, {\small GASLIMIT}, {\small POP}, {\small PC}, {\small MSIZE}, {\small GAS}\}

$W_{verylow}$ = \{{\small ADD}, {\small SUB}, {\small NOT}, {\small LT}, {\small GT}, {\small SLT}, {\small SGT}, {\small EQ}, {\small ISZERO}, {\small AND}, {\small OR}, {\small XOR}, {\small BYTE}, {\small CALLDATALOAD}, \newline \noindent\hspace*{1cm} {\small MLOAD}, {\small MSTORE}, {\small MSTORE8}, {\small PUSH*}, {\small DUP*}, {\small SWAP*}\}

$W_{low}$ = \{{\small MUL}, {\small DIV}, {\small SDIV}, {\small MOD}, {\small SMOD}, {\small SIGNEXTEND}\}

$W_{mid}$ = \{{\small ADDMOD}, {\small MULMOD}, {\small JUMP}\}

$W_{high}$ = \{{\small JUMPI}\}

$W_{ext}$ = \{{\small BALANCE}, {\small EXTCODESIZE}, {\small BLOCKHASH}\}

Note the memory cost component, given as the product of $G_{memory}$ and the maximum of 0 \& the ceiling of the number of words in size that the memory must be over the current number of words, $\boldsymbol{\mu}_i$ in order that all accesses reference valid memory whether for read or write. Such accesses must be for non-zero number of bytes.

Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory to be extended to the beginning of the range. $\boldsymbol{\mu}'_i$ is defined as this new maximum number of words of active memory; special-cases are given where these two are not equal.

Note also that $C_{memory}$ is the memory cost function (the expansion function being the difference between the cost before and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 724B of memory used, after which it costs substantially more.

While defining the instruction set, we defined the memory-expansion for range function, $M$, thus:

\begin{equation}
M(s, f, l) \equiv \begin{cases}
s & \text{if} \quad l = 0 \\
\max(s, \ceil{ (f + l) \div 32 }) & \text{otherwise}
\end{cases}
\end{equation}

\subsection{Instruction Set}

As previously specified in section \ref{ch:model}, these definitions take place in the final context there. In particular we assume $O$ is the EVM state-progression function and define the terms pertaining to the next cycle's state $(\boldsymbol{\sigma}', \boldsymbol{\mu}')$ such that:
\begin{equation}
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \equiv (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \quad \text{with exceptions, as noted}
\end{equation}

Here given are the various exceptions to the state transition rules given in section \ref{ch:model} specified for each instruction, together with the additional instruction-specific definitions of $J$ and $C$. For each instruction, also specified is $\alpha$, the additional items placed on the stack and $\delta$, the items removed from stack, as defined in section \ref{ch:model}.

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{0s: Stop and Arithmetic Operations}} \\
\multicolumn{5}{l}{All arithmetic is modulo $2^{256}$ unless otherwise noted.} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x00 & {\small STOP} & 0 & 0 & Halts execution. \\
\midrule
0x01 & {\small ADD} & 2 & 1 & Addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x02 & {\small MUL} & 2 & 1 & Multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x03 & {\small SUB} & 2 & 1 & Subtraction operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] - \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x04 & {\small DIV} & 2 & 1 & Integer division operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \lfloor\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]\rfloor & \text{otherwise}\end{cases}$  \\
\midrule
0x05 & {\small SDIV} & 2 & 1 & Signed integer division operation (truncated). \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ -2^{255} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = -2^{255} \wedge \quad \boldsymbol{\mu}_\mathbf{s}[1] = -1\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]) \lfloor |\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]| \rfloor & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
&&&& Note the overflow semantic when $-2^{255}$ is negated.\\
\midrule
0x06 & {\small MOD} & 2 & 1 & Modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \boldsymbol{\mu}_\mathbf{s}[0] \bmod \boldsymbol{\mu}_\mathbf{s}[1] & \text{otherwise}\end{cases}$  \\
\midrule
0x07 & {\small SMOD} & 2 & 1 & Signed modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0]) |\boldsymbol{\mu}_\mathbf{s}[0]| \bmod |\boldsymbol{\mu}_\mathbf{s}[1]| & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x08 & {\small ADDMOD} & 3 & 1 & Modulo addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x09 & {\small MULMOD} & 3 & 1 & Modulo multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x0a & {\small EXP} & 2 & 1 & Exponential operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] ^ {\boldsymbol{\mu}_\mathbf{s}[1] }$ \\
\midrule
0x0b & {\small SIGNEXTEND} & 2 & 1 & Extend length of two's complement signed integer. \\
&&&& $ \forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_t &\text{if} \quad i \leqslant t \quad \text{where} \; t = 256 - 8(\boldsymbol{\mu}_\mathbf{s}[0] + 1) \\ \boldsymbol{\mu}_\mathbf{s}[1]_i &\text{otherwise} \end{cases}$ \\
\multicolumn{5}{l}{$\boldsymbol{\mu}_\mathbf{s}[x]_i$ gives the $i$th bit (counting from zero) of $\boldsymbol{\mu}_\mathbf{s}[x]$} \vspace{5pt} \\
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{10s: Comparison \& Bitwise Logic Operations}} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x10 & {\small LT} & 2 & 1 & Less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x11 & {\small GT} & 2 & 1 & Greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x12 & {\small SLT} & 2 & 1 & Signed less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x13 & {\small SGT} & 2 & 1 & Signed greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x14 & {\small EQ} & 2 & 1 & Equality comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x15 & {\small ISZERO} & 1 & 1 & Simple not operator. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x16 & {\small AND} & 2 & 1 & Bitwise AND operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \wedge \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x17 & {\small OR} & 2 & 1 & Bitwise OR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \vee \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x18 & {\small XOR} & 2 & 1 & Bitwise XOR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \oplus \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x19 & {\small NOT} & 1 & 1 & Bitwise NOT operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0]_i = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x1a & {\small BYTE} & 2 & 1 & Retrieve single byte from word. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_{(i + 8\boldsymbol{\mu}_\mathbf{s}[0])} & \text{if} \quad i < 8 \wedge \boldsymbol{\mu}_\mathbf{s}[0] < 32 \\ 0 & \text{otherwise} \end{cases} $\\
&&&& For Nth byte, we count from the left (i.e. N=0 would be the most significant in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{20s: SHA3}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x20 & {\small SHA3} & 2 & 1 & Compute Keccak-256 hash. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \mathtt{\tiny Keccak}(\boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$ \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{30s: Environmental Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x30 & {\small ADDRESS} & 0 & 1 & Get address of currently executing account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_a$ \\
\midrule
0x31 & {\small BALANCE} & 1 & 1 & Get balance of the given account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}\boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0]]_b& \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}] \neq \varnothing\\0&\text{otherwise}\end{cases}$ \\
\midrule
0x32 & {\small ORIGIN} & 0 & 1 & Get execution origination address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_o$ \\
&&&& This is the sender of original transaction; it is never an account with non-empty \\
&&&& associated code. \\
\midrule
0x33 & {\small CALLER} & 0 & 1 & Get caller address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_s$ \\
&&&& This is the address of the account that is directly responsible for this execution. \\
\midrule
0x34 & {\small CALLVALUE} & 0 & 1 & Get deposited value by the instruction/transaction responsible for this execution. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_v$ \\
\midrule
0x35 & {\small CALLDATALOAD} & 1 & 1 & Get input data of current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_\mathbf{d}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \quad \text{with} \quad I_\mathbf{d}[x] = 0 \quad \text{if} \quad x \geqslant \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x36 & {\small CALLDATASIZE} & 0 & 1 & Get size of input data in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x37 & {\small CALLDATACOPY} & 3 & 0 & Copy input data in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{d}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{d} \rVert \\ 0 & \text{otherwise} \end{cases}$\\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x38 & {\small CODESIZE} & 0 & 1 & Get size of code running in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{b} \rVert$ \\
\midrule
0x39 & {\small CODECOPY} & 3 & 0 & Copy code running in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{b} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
\midrule
0x3a & {\small GASPRICE} & 0 & 1 & Get price of gas in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_p$ \\
&&&& This is gas price specified by the originating transaction.\\
\midrule
0x3b & {\small EXTCODESIZE} & 1 & 1 & Get size of an account's code. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c \rVert$ \\
\midrule
0x3c & {\small EXTCODECOPY} & 4 & 0 & Copy an account's code to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[3] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[1] + i ] \equiv
\begin{cases} \mathbf{c}[\boldsymbol{\mu}_\mathbf{s}[2] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] + i < \lVert \mathbf{c} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
&&&& where $\mathbf{c} \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{40s: Block Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x40 & {\small BLOCKHASH} & 1 & 1 & Get the hash of one of the 256 most recent complete blocks. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv P(I_{H_p}, \boldsymbol{\mu}_\mathbf{s}[0], 0)$ \\
&&&& where $P$ is the hash of a block of a particular number, up to a maximum age.\\
&&&& 0 is left on the stack if the looked for block number is greater than the current block number \\
&&&& or more than 256 blocks behind the current block. \\
&&&& $P(h, n, a) \equiv \begin{cases} 0 & \text{if} \quad n > H_i \vee a = 256 \vee h = 0 \\ h & \text{if} \quad n = H_i \\ P(H_p, n, a + 1) & \text{otherwise} \end{cases}$ \\
&&&& and we assert the header $H$ can be determined as its hash is the parent hash \\
&&&& in the block following it. \\
\midrule
0x41 & {\small COINBASE} & 0 & 1 & Get the block's beneficiary address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_c$ \\
\midrule
0x42 & {\small TIMESTAMP} & 0 & 1 & Get the block's timestamp. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_s$ \\
\midrule
0x43 & {\small NUMBER} & 0 & 1 & Get the block's number. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_i$ \\
\midrule
0x44 & {\small DIFFICULTY} & 0 & 1 & Get the block's difficulty. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_d$ \\
\midrule
0x45 & {\small GASLIMIT} & 0 & 1 & Get the block's gas limit. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_l$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{50s: Stack, Memory, Storage and Flow Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x50 & {\small POP} & 1 & 0 & Remove item from stack. \\
\midrule
0x51 & {\small MLOAD} & 1 & 1 & Load word from memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
\midrule
0x52 & {\small MSTORE} & 2 & 0 & Save word to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
\midrule
0x53 & {\small MSTORE8} & 2 & 0 & Save byte to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv (\boldsymbol{\mu}_\mathbf{s}[1] \bmod 256) $ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 1) \div 32 })$ \\
\midrule
0x54 & {\small SLOAD} & 1 & 1 & Load word from storage. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]]$ \\
\midrule
0x55 & {\small SSTORE} & 2 & 0 & Save word to storage. \\
&&&& $\boldsymbol{\sigma}'[I_a]_\mathbf{s}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv \boldsymbol{\mu}_\mathbf{s}[1] $ \\
&&&& $C_{\text{\tiny SSTORE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{sset} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] = 0 \\
G_{sreset} & \text{otherwise}
\end{cases}$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{sclear} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0x56 & {\small JUMP} & 1 & 0 & Alter the program counter. \\
&&&& $J_{\text{\tiny JUMP}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{s}[0] $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x57 & {\small JUMPI} & 2 & 0 & Conditionally alter the program counter. \\
&&&& $J_{\text{\tiny JUMPI}}(\boldsymbol{\mu}) \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[0] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \\ \boldsymbol{\mu}_{pc} + 1 & \text{otherwise} \end{cases} $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x58 & {\small PC} & 0 & 1 & Get the value of the program counter \textit{prior} to the increment \\
&&&&  corresponding to this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{pc}$ \\
\midrule
0x59 & {\small MSIZE} & 0 & 1 & Get the size of active memory in bytes. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv 32\boldsymbol{\mu}_{i}$ \\
\midrule
0x5a & {\small GAS} & 0 & 1 & Get the amount of available gas, including the corresponding reduction \\
&&&& for the cost of this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{g}$ \\
\midrule
0x5b & {\small JUMPDEST} & 0 & 0 & Mark a valid destination for jumps. \\
&&&& This operation has no effect on machine state during execution. \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{60s \& 70s: Push Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x60 & {\small PUSH1} & 0 & 1 & Place 1 byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv c(\boldsymbol{\mu}_{pc} + 1)$ \\
&&&& $\text{where} \quad c(x) \equiv \begin{cases} I_\mathbf{b}[x] & \text{if} \quad x < \lVert I_\mathbf{b} \rVert \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& The bytes are read in line from the program code's bytes array. \\
&&&& The function $c$ ensures the bytes default to zero if they extend past the limits.\\
&&&& The byte is right-aligned (takes the lowest significant place in big endian). \\
\midrule
0x61 & {\small PUSH2} & 0 & 1 & Place 2-byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 2) \big)$ \\
&&&& with $\boldsymbol{c}(\boldsymbol{x}) \equiv (c(\boldsymbol{x}_0), ..., c(\boldsymbol{x}_{\lVert x \rVert -1})) $ with $c$ as defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x7f & {\small PUSH32} & 0 & 1 & Place 32-byte (full word) item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big((\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 32) \big)$ \\
&&&& where $\boldsymbol{c}$ is defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{80s: Duplication Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x80 & {\small DUP1} & 1 & 2 & Duplicate 1st stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x81 & {\small DUP2} & 2 & 3 & Duplicate 2nd stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x8f & {\small DUP16} & 16 & 17 & Duplicate 16th stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[15]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{90s: Exchange Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x90 & {\small SWAP1} & 2 & 2 & Exchange 1st and 2nd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[1] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x91 & {\small SWAP2} & 3 & 3 & Exchange 1st and 3rd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[2]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[2] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x9f & {\small SWAP16} & 17 & 17 & Exchange 1st and 17th stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[16]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[16] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{a0s: Logging Operations}} \vspace{5pt} \\
\multicolumn{5}{l}{For all logging operations, the state change is to append an additional log entry on to the substate's log series:}\\
\multicolumn{5}{l}{$A'_\mathbf{l} \equiv A_\mathbf{l} \cdot (I_a, \mathbf{t}, \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$}\\
\multicolumn{5}{l}{The entry's topic series, $\mathbf{t}$, differs accordingly:}\vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xa0 & {\small LOG0} & 2 & 0 & Append log record with no topics. \\
&&&& $\mathbf{t} \equiv ()$ \\
\midrule
0xa1 & {\small LOG1} & 3 & 0 & Append log record with one topic. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2])$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0xa4 & {\small LOG4} & 6 & 0 & Append log record with four topics. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4], \boldsymbol{\mu}_\mathbf{s}[5])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{f0s: System operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xf0 & {\small CREATE} & 3 & 1 & Create a new account with associated code. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[1] \dots (\boldsymbol{\mu}_\mathbf{s}[1] + \boldsymbol{\mu}_\mathbf{s}[2] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', \boldsymbol{\mu}'_g, A^+) \equiv \begin{cases}\Lambda(\boldsymbol{\sigma}^*, I_a, I_o, \boldsymbol{\mu}_g, I_p, \boldsymbol{\mu}_\mathbf{s}[0], \mathbf{i}, I_e + 1) & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024\\ \big(\boldsymbol{\sigma}, \boldsymbol{\mu}_g, \varnothing\big) & \text{otherwise} \end{cases}$ \\
&&&& $\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except} \quad \boldsymbol{\sigma}^*[I_a]_n = \boldsymbol{\sigma}[I_a]_n + 1$ \\
&&&& $A' \equiv A \Cup A^+$ which implies: $A'_\mathbf{s} \equiv A_\mathbf{s} \cup A^+_\mathbf{s} \quad \wedge \quad A'_\mathbf{l} \equiv A_\mathbf{l} \cdot A^+_\mathbf{l} \quad \wedge \quad A'_\mathbf{r} \equiv A_\mathbf{r} + A^+_\mathbf{r}$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}^*, \boldsymbol{\mu}, I) = \top$ or $I_e = 1024$ \\
&&&& (the maximum call depth limit is reached) or $\boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\sigma}[I_a]_b$ (balance of the caller is too \\
&&&& low to fulfil the value transfer); and otherwise $x=A(I_a, \boldsymbol{\sigma}[I_a]_n)$, the address of the newly \\
&&&& created account, otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[1], \boldsymbol{\mu}_\mathbf{s}[2])$ \\
&&&& Thus the operand order is: value, input offset, input size. \\
\midrule
0xf1 & {\small CALL} & 7 & 1 & Message-call into an account. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[3] \dots (\boldsymbol{\mu}_\mathbf{s}[3] + \boldsymbol{\mu}_\mathbf{s}[4] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, I_a, I_o, t, t,\\ \quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024\\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& $n \equiv \min(\{ \boldsymbol{\mu}_\mathbf{s}[6], |\mathbf{o}|\})$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[5] \dots (\boldsymbol{\mu}_\mathbf{s}[5] + n - 1) ] = \mathbf{o}[0 \dots (n - 1)]$ \\
&&&& $\boldsymbol{\mu}'_g \equiv \boldsymbol{\mu}_g + g'$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& $A' \equiv A \Cup A^+$ \\
&&&& $t \equiv \boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) = \top$ or if  \\
&&&& $\boldsymbol{\mu}_\mathbf{s}[2] > \boldsymbol{\sigma}[I_a]_b$ (not enough funds) or $I_e = 1024$ (call depth limit reached); $x=1$ \\
&&&& otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4]), \boldsymbol{\mu}_\mathbf{s}[5], \boldsymbol{\mu}_\mathbf{s}[6])$ \\
&&&& Thus the operand order is: gas, to, value, in offset, in size, out offset, out size. \\
&&&& $C_{\text{\tiny CALL}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv G_{call} + \boldsymbol{\mu}_\mathbf{s}[0] + C_{\text{\tiny CALLXFER}}(\boldsymbol{\mu}) + C_{\text{\tiny CALLNEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$ \\
&&&& $C_{\text{\tiny CALLXFER}}(\boldsymbol{\mu}) \equiv \begin{cases}
G_{callvalue} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny CALLNEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{callnewaccount} & \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}] = \varnothing \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}) \equiv  \begin{cases}
\boldsymbol{\mu}_\mathbf{s}[0] + G_{callstipend} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0xf2 & {\small CALLCODE} & 7 & 1 & Message-call into this account with alternative account's code. \\
&&&& Exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_a, I_o, I_a, t,\\\quad \boldsymbol{\mu}_\mathbf{s}[0], I_p, \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024 \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the change in the fourth parameter to the call $\Theta$ from the 2nd stack value $\boldsymbol{\mu}_\mathbf{s}[1]$\\
&&&& (as in {\small CALL}) to the present address $I_a$. This means that the recipient is in fact the\\
&&&& same account as at present, simply that the code is overridden altered.\\
\midrule
0xf3 & {\small RETURN} & 2 & 0 & Halt execution returning output data. \\
&&&& $H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots ( \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1 ) ]$ \\
&&&& This has the effect of halting the execution at this point with output defined.\\
&&&& See section \ref{ch:model}. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\midrule
0xff & {\small SUICIDE} & 1 & 0 & Halt execution and register account for later deletion. \\
&&&& $A'_\mathbf{s} \equiv A_\mathbf{s} \cup \{ I_a \}$ \\
&&&& $\boldsymbol{\sigma}'[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b + \boldsymbol{\sigma}[I_a]_b$ \\
&&&& $\boldsymbol{\sigma}'[I_a]_b \equiv 0$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{suicide} & \text{if} \quad I_a \notin A_\mathbf{s} \\
0 & \text{otherwise}
\end{cases}$ \\\bottomrule
\end{tabular*}

%\section{Low-level Lisp-like Language}\label{app:lll}
%The Low-level Lisp-like Language is a language created in order to efficiently author low-level programs (contracts) without having to resort to EVM-Assembly.

\section{Genesis Block}\label{app:genesis}

The genesis block is 15 items, and is specified thus:
\begin{equation}
\big( \big( 0_{256}, \mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big), 0_{160}, stateRoot, 0, 0, 0_{2048}, 2^{17}, 0, 0, 3141592, time, 0, 0_{256},  \mathtt{\tiny KEC}\big( (42) \big) \big), (), () \big)
\end{equation}

Where $0_{256}$ refers to the parent hash, a 256-bit hash which is all zeroes; $0_{160}$ refers to the beneficiary address, a 160-bit hash which is all zeroes; $0_{2048}$ refers to the log bloom, 2048-bit of all zeros; $2^{17}$ refers to the difficulty; the transaction trie root, receipt trie root, gas used, block number and extradata are both $0$, being equivalent to the empty byte array. The sequences of both ommers and transactions are empty and represented by $()$. $\mathtt{\tiny KEC}\big( (42) \big)$ refers to the Keccak hash of a byte array of length one whose first and only byte is of value 42, used for the nonce. $\mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big)$ value refers to the hash of the ommer lists in RLP, both empty lists.

The proof-of-concept series include a development premine, making the state root hash some value $stateRoot$. Also $time$ will be set to the intial timestamp of the genesis block. The latest documentation should be consulted for those values.

\section{Ethash}\label{app:ethash}
\subsection{Definitions}
We employ the following definitions:

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description \\
\midrule
$J_{wordbytes}$ & 4  & Bytes in word. \\
$J_{datasetinit}$ & $2^{30}$ & Bytes in dataset at genesis. \\
$J_{datasetgrowth}$ & $2^{23}$ & Dataset growth per epoch. \\
$J_{cacheinit}$ & $2^{24}$ & Bytes in cache at genesis. \\
$J_{cachegrowth}$ & $2^{17}$ & Cache growth per epoch. \\
$J_{epoch}$ & 30000 & Blocks per epoch. \\
$J_{mixbytes}$ & 128 & mix length in bytes. \\
$J_{hashbytes}$ & 64 & Hash length in bytes. \\
$J_{parents}$ & 256 & Number of parents of each dataset element. \\
$J_{cacherounds}$ & 3 & Number of rounds in cache production. \\
$J_{accesses}$ & 64 & Number of accesses in hashimoto loop. \\
\bottomrule
\end{tabular*}

\subsection{Size of dataset and cache}
The size for Ethash's cache $\mathbf{c} \in \mathbb{B}$  and dataset $\mathbf{d} \in \mathbb{B}$ depend on the epoch, which in turn depends on the block number.
\begin{equation}
 E_{epoch}(H_i) = \left\lfloor\frac{H_i}{J_{epoch}}\right\rfloor
\end{equation}
The size of the dataset growth by $J_{datasetgrowth}$ bytes, and the size of the cache by $J_{cachegrowth}$ bytes, every epoch. In order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a multiple of $J_{mixbytes}$, for the dataset, and $J_{hashbytes}$ for the cache. 
Let $d_{size} = \lVert \mathbf{d} \rVert$ be the size of the dataset. Which is calculated using
\begin{equation}
 d_{size} = E_{prime}(J_{datasetinit} + J_{datasetgrowth} \cdot E_{epoch} - J_{mixbytes}, J_{mixbytes})
\end{equation}
The size of the cache, $c_{size}$, is calculated using
\begin{equation}
 c_{size} = E_{prime}(J_{cacheinit} + J_{cachegrowth} \cdot E_{epoch} - J_{hashbytes}, J_{hashbytes})
\end{equation}
\begin{equation}
 E_{prime}(x, y) = \begin{cases}
x & \text{if} \quad x / y \in \mathbb{P} \\
E_{prime}(x - 1 \cdot y, y) & \text{otherwise}
\end{cases}
\end{equation}
\subsection{Dataset generation}
In order the generate the dataset we need the cache $\mathbf{c}$, which is an array of bytes. It depends on the cache size  $c_{size}$ and the seed hash $\mathbf{s} \in \mathbb{B}_{32}$. 
\subsubsection{Seed hash}
The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
\begin{equation}
 \mathbf{s} = C_{seedhash}(H_i)
\end{equation}
\begin{equation}
 C_{seedhash}(H_i) = \begin{cases}
\texttt{KEC}(\mathbf{0}_{32}) & \text{if} \quad E_{epoch}(H_i) = 0 \quad  \\
\texttt{KEC}(C_{seedhash}(H_i - J_{epoch})) & \text{otherwise}
\end{cases}
\end{equation}
With $\mathbf{0}_{32}$ being 32 bytes of zeros.

\subsubsection{Cache}
The cache production process involves using the seed hash to first sequentially filling up $c_{size}$ bytes of memory, then performing $J_{cacherounds}$ passes of the RandMemoHash algorithm created by \cite{lerner2014randmemohash}. The intial cache $\mathbf{c'}$, being an array of arrays of single bytes, will be constructed as follows.

We define the array $\mathbf{c}_{i}$, consisting of 64 single bytes,  as the $i$th element of the intial cache:
\begin{equation}
 \mathbf{c}_{i} = \begin{cases}
\texttt{KEC512}(\mathbf{s}) & \text{if} \quad i = 0 \quad  \\
\texttt{KEC512}(\mathbf{c}_{i-1}) & \text{otherwise}
\end{cases}
\end{equation}
Therefore $ \mathbf{c'}$ can be defined as 
\begin{equation}
 \mathbf{c'}[i] = \mathbf{c}_{i} \quad \forall \quad i < n
\end{equation}
\begin{equation}
 n = \left\lfloor\frac{c_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
The cache is calculated by performing $J_{cacherounds}$ rounds of the RandMemoHash algorithm to the inital cache $\mathbf{c'}$:
\begin{equation}
 \mathbf{c} = E_{cacherounds}(\mathbf{c'}, J_{cacherounds})
\end{equation}
\begin{equation}
 E_{cacherounds}(\mathbf{x}, y) = \begin{cases}
\mathbf{x} & \text{if} \quad y = 0 \quad  \\
E_\text{\tiny RMH}(\mathbf{x}) & \text{if} \quad y = 1 \quad  \\
E_{cacherounds}(E_\text{\tiny RMH}(\mathbf{x}), y -1 ) & \text{otherwise}
\end{cases}
\end{equation}
Where a single round modifies each subset of the cache as follows:
\begin{equation}
 E_\text{\tiny RMH}(\mathbf{x}) = \lbrace E_{rmh}(\mathbf{x}, 0), E_{rmh}(\mathbf{x}, 1), ... , E_{rmh}(\mathbf{x}, n - 1) \rbrace
\end{equation}
\begin{multline}
  E_{rmh}(\mathbf{x}, i) = \texttt{KEC512}(\mathbf{x'}[(i - 1 + n) \mod n] \oplus \mathbf{x'}[\mathbf{x'}[i][0] \mod n]) \\
  \text{with} \quad \mathbf{x'} = \mathbf{x} \quad \text{except} \quad \mathbf{x'}[j] = E_{rmh}(\mathbf{x}, j) \quad \forall \quad j < i
\end{multline}

\subsubsection{Full dataset calculation} \label{dataset} 
Essentially, we combine data from $J_{parents}$ pseudorandomly selected cache nodes, and hash that to compute the dataset. The entire dataset is then generated by $d_{size}$ items, each $J_{hashbytes}$ bytes in size:
\begin{equation}
 \mathbf{d}[i] = E_{datasetitem}(\mathbf{c}, i) \quad \forall \quad i < \left\lfloor\frac{d_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to calculate the single item we use an algorithm inspired by the FNV hash (\cite{FowlerNollVo1991FNVHash}) in some cases as a non-associative substitute for XOR.
\begin{equation}
 E_\text{\tiny FNV}(\mathbf{x}, \mathbf{y}) = (\mathbf{x} \cdot (\mathrm{0x01000193} \oplus \mathbf{y})) \mod 2^{32}
\end{equation}
The single item of the dataset can now be calculated as:
\begin{equation}
 E_{datasetitem}(\mathbf{c}, i) = E_{parents}(\mathbf{c}, i, -1, \varnothing)
\end{equation}
\begin{equation}
  E_{parents}(\mathbf{c}, i, p, \mathbf{m}) = \begin{cases}
E_{parents}(\mathbf{c}, i, p +1, E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1)) & \text{if} \quad p < J_{parents} -2 \\
E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mix}(\mathbf{m}, \mathbf{c}, i, p) = \begin{cases}
\texttt{KEC512}(\mathbf{c}[i \mod c_{size}] \oplus i) & \text{if} \quad p = 0 \\
E_\text{\tiny FNV}(\mathbf{m}, \mathbf{c}[E_\text{\tiny FNV}(i \oplus p, \mathbf{m}[p \mod \lfloor J_{hashbytes} / J_{wordbytes} \rfloor]) \mod c_{size}] & \text{otherwise}
\end{cases}
\end{equation}

\subsection{Proof-of-work function}
Essentially, we maintain a "mix" $J_{mixbytes}$ bytes wide, and repeatedly sequentially fetch $J_{mixbytes}$ bytes from the full dataset and use the $E_\text{\tiny FNV}$ function to combine it with the mix. $J_{mixbytes}$ bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.

If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of \texttt{KEC} at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.

The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the concatenation of the compressed mix with the seed hash as the second item:
\begin{equation}
 \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d}) = \lbrace \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d}), \texttt{KEC}(\mathbf{s}_h(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n) + \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d})) \rbrace
\end{equation}
With $H_{\hcancel{n}}$ being the hash of the header without the nonce. The compressed mix $\mathbf{m}_c$ is obtained as follows:
\begin{equation}
 \mathbf{m}_c(\mathbf{h}, \mathbf{n}, \mathbf{d}) = E_{compress}(E_{accesses}(\mathbf{d}, \sum_{i = 0}^{n_{mix}} \mathbf{s}_h(\mathbf{h}, \mathbf{n}), \mathbf{s}_h(\mathbf{h}, \mathbf{n}), -1), -4)
\end{equation}

The seed hash being:
\begin{equation}
 \mathbf{s}_h(\mathbf{h}, \mathbf{n}) = \texttt{KEC512}(\mathbf{h} + E_{revert}(\mathbf{n}))
\end{equation}
$E_{revert}(\mathbf{n})$ returns the reverted bytes sequence of the nonce $\mathbf{n}$:
\begin{equation}
 E_{revert}(\mathbf{n})[i] = \mathbf{n}[\lVert \mathbf{n} \rVert -i]
\end{equation}
We note that the ``$+$''-operator between two byte sequences results in the concatenation of both sequences.

The dataset $\mathbf{d}$ is obtained as described in section \ref{dataset}.

The number of replicated sequences in the mix is:
\begin{equation}
 n_{mix} =  \left\lfloor\frac{J_{mixbytes}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to add random dataset nodes to the mix, the $E_{accesses}$ function is used:
\begin{equation}
 E_{accesses}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = \begin{cases}
E_{mixdataset}(\mathbf{d}, \mathbf{m},  \mathbf{s}, i) & \text{if} \quad i = J_{accesses} -2 \\
E_{accesses}(E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i), \mathbf{s}, i + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = E_\text{\tiny FNV}(\mathbf{m}, E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)
\end{equation}
$E_{newdata}$ returns an array with $n_{mix}$ elements:
\begin{equation}
 E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)[j] = \mathbf{d}[E_\text{\tiny FNV}(i \oplus \mathbf{s}[0], \mathbf{m}[i \mod \left\lfloor\frac{J_{mixbytes}}{J_{wordbytes}}\right\rfloor]) \mod \left\lfloor\frac{d_{size} / J_{hashbytes}}{n_{mix}}\right\rfloor \cdot n_{mix} + j] \quad \forall \quad j < n_{mix}
\end{equation}
The mix is compressed as follows:
\begin{equation}
 E_{compress}(\mathbf{m}, i) = \begin{cases}
\mathbf{m} & \text{if} \quad i \geqslant \lVert \mathbf{m} \rVert - 8 \\
E_{compress}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(\mathbf{m}[i + 4], \mathbf{m}[i + 5]), \mathbf{m}[i + 6]), \mathbf{m}[i + 7]), i + 8) & \text{otherwise}
\end{cases}
\end{equation}

\subsection{Mining}
In order to mine a valid block, one repeatedly chooses a random nonce $\mathbf{n}_{rand} \in \mathbb{B}_{8}$ and calculates the $\mathtt{PoW}$ function until
\begin{equation}
 \mathtt{PoW}(H_{\hcancel{n}}, \mathbf{n}_{rand}, \mathbf{d})[1] \leqslant \frac{2^{256}}{H_d}\quad.
\end{equation}
$H_d$ being the current difficulty of the block.
\end{document}
